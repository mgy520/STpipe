{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-stpipe-documentation","title":"Welcome to STpipe documentation!","text":"<p>STpipe is a Python package designed for Spatial transcriptomics data analysis.  It provides various tools and utilities for processing, analyzing,  and visualizing data. </p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Installation: Instructions for installing STpipe using pip.</li> <li>Tutorial: The tutorial provides a step-by-step guide on how to use   STpipe for Spatial transcriptomics data analysis. It covers various aspects of   data processing, analysis, and visualization using STpipe   functionalities.</li> <li>API Reference:  The API reference contains detailed documentation   of all the modules, classes, and functions in STpipe.</li> <li>License: License information</li> </ul>"},{"location":"API%20Reference/function/Spatial_cluster/","title":"Spatial cluster","text":""},{"location":"API%20Reference/function/Spatial_cluster/#stpipe.cluster","title":"<code>stpipe.cluster(cdata, K_set, neighborhood_size, n_PCs)</code>","text":"<p>Spatial transcriptomics data spatial clustering.</p> <p>Parameters:</p> Name Type Description Default <code>cdata</code> <code>Anndata</code> <p>Anndata object for Spatial transcriptomics data.</p> required <code>K_set</code> <code>list</code> <p>List of integers specifying the range of cluster numbers to consider.for example:np.arange(10,30)</p> required <code>neighborhood_size</code> <code>int</code> <p>Size of the neighborhood for computing adjacency matrix.</p> required <code>n_PCs</code> <code>int</code> <p>Number of principal components to use.</p> required <p>Returns:</p> Name Type Description <code>cdata</code> <code>Anndata</code> <p>An Anndata object with cluster labels assigned to observations.</p>"},{"location":"API%20Reference/function/falsepositive/","title":"Falsepositive","text":""},{"location":"API%20Reference/function/falsepositive/#stpipe.function.falsepositive","title":"<code>stpipe.function.falsepositive(ad_sp, ad_sc, train_gene=[], device='cuda:0', density_prior='rna_count_based', celltype=None)</code>","text":"<p>Identify false-positive genes between Spatial transcriptomics data and scRNA-seq data.</p> <p>Parameters:</p> Name Type Description Default <code>ad_sp</code> <code>AnnData</code> <p>Anndata object containing Spatial transcriptomics data.</p> required <code>ad_sc</code> <code>AnnData</code> <p>Anndata object containing scRNA-seq data.</p> required <code>train_gene</code> <code>list</code> <p>List of genes to use for training. Default is an empty list.</p> <code>[]</code> <code>density_prior</code> <code>(str, ndarray or None)</code> <p>Spatial density of spots, when is a string, value can be 'rna_count_based' or 'uniform', when is a ndarray, shape = (number_spots,). This array should satisfy the constraints sum() == 1. If None, the density term is ignored. Default value is 'rna_count_based'.</p> <code>'rna_count_based'</code> <code>device</code> <code>str</code> <p>Device to use for computation. Default is 'cuda:0'.</p> <code>'cuda:0'</code> <code>celltype</code> <code>str or None</code> <p>Cell type key in ad_sp.obs. If provided, the cell types in the scRNA-seq will be mapped to the spatial transcriptomic data. Default value is None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>moran_ad_sp</code> <code>Series</code> <p>Pandas series containing Moran's I statistic for Spatial transcriptomics data.</p> <code>moran_ad_sc</code> <code>Series</code> <p>Pandas series containing Moran's I statistic for scRNA-seq data.</p> <code>ad_ge</code> <code>AnnData</code> <p>AnnData object represents the scRNA-seq data mapping to the Spatial transcriptomics space.</p> <code>as_sp</code> <code>AnnData</code> <p>ad_sp with celltype</p>"},{"location":"API%20Reference/function/filtercells/","title":"Filtercells","text":""},{"location":"API%20Reference/function/filtercells/#stpipe.function.filter_cells","title":"<code>stpipe.function.filter_cells(adata, min_genes)</code>","text":"<p>Retain cells that express a minimum number of genes.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An anndata object.</p> required <code>min_genes</code> <code>int</code> <p>The minimum number of genes a cell expresses.</p> required <p>Returns:</p> Name Type Description <code>adata</code> <code>AnnData</code> <p>A filtered anndata object.</p>"},{"location":"API%20Reference/function/filtergenes/","title":"Filtergenes","text":""},{"location":"API%20Reference/function/filtergenes/#stpipe.function.filter_genes","title":"<code>stpipe.function.filter_genes(adata, min_cells)</code>","text":"<p>Retain genes that are expressed in at least a specified number of cells.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An anndata object.</p> required <code>min_cells</code> <code>int</code> <p>The minimum number of cells in which a gene is expressed.</p> required <p>Returns:</p> Name Type Description <code>adata</code> <code>AnnData</code> <p>A filtered anndata object.</p>"},{"location":"API%20Reference/function/findmarkers/","title":"Findmarkers","text":""},{"location":"API%20Reference/function/findmarkers/#stpipe.Findmarkers","title":"<code>stpipe.Findmarkers</code>","text":""},{"location":"API%20Reference/function/findmarkers/#stpipe.Findmarkers.find_markers_between_groups","title":"<code>find_markers_between_groups(cdata, cluster_key, group1, group2, min_pct=0.1, only_pos=True)</code>","text":"<p>Find marker genes between two specified groups in cdata.</p> <p>Parameters:</p> Name Type Description Default <code>cdata</code> <code>Anndata</code> <p>An Anndata object containing the single-cell data.</p> required <code>cluster_key</code> <code>str</code> <p>The key representing the cell cluster annotations in the observation metadata of the Anndata object.</p> required <code>group1</code> <code>str</code> <p>The name of the first group for comparison.</p> required <code>group2</code> <code>str</code> <p>The name of the second group for comparison.</p> required <code>min_pct</code> <code>float</code> <p>The minimum percentage threshold for filtering sparse genes. Defaults to 0.1.</p> <code>0.1</code> <code>only_pos</code> <code>bool</code> <p>Whether to consider only genes with positive log2 fold change. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>cdata</code> <code>Anndata</code> <p>An Anndata object with marker genes identified between the specified groups. The marker genes and related statistical information are stored in the <code>uns</code> attribute of the Anndata object under a key formatted as 'DGE_group1_group2'.</p>"},{"location":"API%20Reference/function/findmarkers/#stpipe.Findmarkers.findallmarkers","title":"<code>findallmarkers(cdata, cluster_key, min_pct=0.1, only_pos=True)</code>","text":"<p>Find marker genes for each cluster in Spatial transcriptomics data.</p> <p>Parameters:</p> Name Type Description Default <code>cdata</code> <code>Anndata</code> <p>An Anndata object.</p> required <code>cluster_key</code> <code>str</code> <p>The key representing the cell cluster annotations in the observation metadata of the Anndata object.</p> required <code>min_pct</code> <code>float</code> <p>The minimum percentage threshold for filtering sparse genes. Defaults to 0.1.</p> <code>0.1</code> <code>only_pos</code> <code>bool</code> <p>Whether to consider only genes with positive log2 fold change. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>cdata</code> <code>Anndata</code> <p>An Anndata object with marker genes identified for each cell cluster. The marker genes and related statistical information are stored in the <code>uns</code> attribute of the Anndata object under the key 'markers_all'.</p>"},{"location":"API%20Reference/function/findneighbors/","title":"Findneighbors","text":""},{"location":"API%20Reference/function/findneighbors/#stpipe.function.find_neighbors","title":"<code>stpipe.function.find_neighbors(adata, n_components=30, n_neighbors=10, metric='euclidean', n_jobs=1)</code>","text":"<p>Find nearest neighbors in PCA space.</p> <p>This function finds the nearest neighbors in the principal component analysis (PCA) space of the given Anndata object.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Anndata object containing gene expression data.</p> required <code>n_components</code> <code>int</code> <p>Number of principal components to use. Default is 30.</p> <code>30</code> <code>n_neighbors</code> <code>int</code> <p>Number of neighbors to find. Default is 10.</p> <code>10</code> <code>metric</code> <code>str</code> <p>Distance metric to use for finding neighbors. Default is 'euclidean'.</p> <code>'euclidean'</code> <code>n_jobs</code> <code>int</code> <p>Number of parallel jobs to run for neighbor search. Default is 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>adata</code> <code>AnnData</code> <p>Anndata object with neighbor information stored in the 'uns' attribute under the key 'neighbors'. The neighbor distances are stored in 'dist' and neighbor indices are stored in 'indices'.</p>"},{"location":"API%20Reference/function/format/","title":"Format","text":""},{"location":"API%20Reference/function/format/#stpipe.format","title":"<code>stpipe.format</code>","text":""},{"location":"API%20Reference/function/format/#stpipe.format.FileProcessor","title":"<code>FileProcessor</code>","text":""},{"location":"API%20Reference/function/format/#stpipe.format.FileProcessor.__init__","title":"<code>__init__(directory='./', p=6, extension='.csv', header='infer', sep=',')</code>","text":"<p>Initialize a FileProcessor object.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>Directory path containing the files to process. Default is './'.</p> <code>'./'</code> <code>p</code> <code>int</code> <p>Number of parallel processes to use. Default is 6.</p> <code>6</code> <code>extension</code> <code>str</code> <p>File extension to filter files. Default is '.csv'.</p> <code>'.csv'</code> <code>header</code> <code>str</code> <p>Row index to use as the header. Default is 'infer'.</p> <code>'infer'</code> <code>sep</code> <code>str</code> <p>Delimiter for reading and writing CSV files. Default is ','.</p> <code>','</code> Warning <p>This class may modify source files during processing. It is recommended to make a backup of the files before use.</p>"},{"location":"API%20Reference/function/format/#stpipe.format.FileProcessor.add_slice_number","title":"<code>add_slice_number(slice_pattern='_([0-9]+)_')</code>","text":"<p>Add slice numbers to the last column of the file based on a given pattern.</p> <p>This method adds slice numbers to the last column of each file in the specified directory based on the provided pattern. It uses parallel processing with the specified number of processes.</p> <p>Parameters:</p> Name Type Description Default <code>slice_pattern</code> <code>str</code> <p>Regular expression pattern to extract slice numbers from filenames.                        Default is r'([0-9]+)'.</p> <code>'_([0-9]+)_'</code> <p>Returns:</p> Name Type Description <code>None</code> <code>NoneType</code> <p>This method operates directly on the files in the specified directory. It does not return any value upon completion.</p>"},{"location":"API%20Reference/function/format/#stpipe.format.FileProcessor.delete_cols","title":"<code>delete_cols(column_indices)</code>","text":"<p>Delete columns from CSV files based on a list of column indices.</p> <p>This method iterates through CSV files in the specified directory and deletes the specified columns from each file.</p> <p>Parameters:</p> Name Type Description Default <code>column_indices</code> <code>list</code> <p>List of column indices to be deleted from each CSV file.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>NoneType</code> <p>This method operates directly on the files in the specified directory. It does not return any value upon completion.</p>"},{"location":"API%20Reference/function/format/#stpipe.format.FileProcessor.delete_rows","title":"<code>delete_rows(column_index=0, value_to_delete=None)</code>","text":"<p>Delete rows from CSV files based on a specific column's value.</p> <p>This method iterates through CSV files in the specified directory and deletes rows from each file where the value in the specified column matches the given value_to_delete.</p> <p>Parameters:</p> Name Type Description Default <code>column_index</code> <code>int</code> <p>Index of the column to consider for deletion. Default is 0.</p> <code>0</code> <code>value_to_delete</code> <code>str or None</code> <p>The value to be matched in the specified column for row deletion.                                  If None, rows are deleted where the column value is empty.                                  Default is None.</p> <code>None</code> <p>Returns:     None (NoneType): This method operates directly on the files in the specified directory. It does not return any value upon completion.</p>"},{"location":"API%20Reference/function/format/#stpipe.format.FileProcessor.merge_h5ad","title":"<code>merge_h5ad(join='outer', index_unique=None, **kwargs)</code>","text":"<p>Merge multiple h5ad files into a single AnnData object.</p> <p>This method searches for h5ad files in the specified directory, reads them using concurrent processing, and then merges them into a single AnnData object.</p> <p>Parameters:</p> Name Type Description Default <code>join</code> <code>str</code> <p>Type of join operation for merging. Options include \"outer\", \"inner\".               Default is \"outer\".</p> <code>'outer'</code> <code>index_unique</code> <code>str</code> <p>If provided, specifies how to handle index values. Default is None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the <code>anndata.concat</code> function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>combined_ad</code> <code>AnnData</code> <p>The merged AnnData object containing data from multiple h5ad files.</p>"},{"location":"API%20Reference/function/format/#stpipe.format.FileProcessor.rename_cols","title":"<code>rename_cols(column_mapping)</code>","text":"<p>Rename columns in CSV files based on a dictionary mapping of old column names to new column names.</p> <p>This method iterates through CSV files in the specified directory and renames columns according to the provided mapping.</p> <p>Parameters:</p> Name Type Description Default <code>column_mapping</code> <code>dict</code> <p>Dictionary mapping old column names to new column names for renaming.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>NoneType</code> <p>This method operates directly on the files in the specified directory. It does not return any value upon completion.</p>"},{"location":"API%20Reference/function/format/#stpipe.format.FileProcessor.reorder_cols","title":"<code>reorder_cols(column_order)</code>","text":"<p>Reorder columns in CSV files based on a specified list of column names.</p> <p>This method iterates through CSV files in the specified directory and reorders columns according to the provided order.</p> <p>Parameters:</p> Name Type Description Default <code>column_order</code> <code>list</code> <p>List of column names specifying the desired order of columns.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>NoneType</code> <p>This method operates directly on the files in the specified directory. It does not return any value upon completion.</p>"},{"location":"API%20Reference/function/format/#stpipe.format.FileProcessor.to_anndata","title":"<code>to_anndata()</code>","text":"<p>Convert files into AnnData objects and save as HDF5 files.</p> <p>This method reads files in the specified directory, processes the data, converts it into AnnData objects, and saves each AnnData object as a separate HDF5 file with the same name as the input file.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>NoneType</code> <p>This method operates directly on the files in the specified directory. It does not return any value upon completion.</p>"},{"location":"API%20Reference/function/generate_membership_anndata/","title":"Generate membership anndata","text":""},{"location":"API%20Reference/function/generate_membership_anndata/#stpipe.function.generate_membership_anndata","title":"<code>stpipe.function.generate_membership_anndata(dd, bb, celltype='cluster')</code>","text":"<p>Generate an Anndata object representing metacell-based gene expression.</p> <p>Parameters:</p> Name Type Description Default <code>dd</code> <code>AnnData</code> <p>Anndata object which .X is raw count.</p> required <code>bb</code> <code>AnnData</code> <p>Anndata object containing spatial membership information.</p> required <code>celltype</code> <code>str</code> <p>The key in bb.obs that represents the cell type</p> <code>'cluster'</code> <p>Returns:</p> Name Type Description <code>Anndata</code> <code>Anndata</code> <p>An Anndata object representing metacell-based gene expression. The expression values are aggregated based on membership categories from the 'membership' column in bb. Spatial coordinates are computed as the centroids of cells belonging to each membership category.</p>"},{"location":"API%20Reference/function/insert_tiff/","title":"Insert tiff","text":""},{"location":"API%20Reference/function/insert_tiff/#stpipe.function.insert_tiff","title":"<code>stpipe.function.insert_tiff(adata, image_dir='./')</code>","text":"<p>Insert TIFF images into Anndata object.</p> <p>This function reads TIFF images from the specified directory and inserts them into the Anndata object.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Anndata object.</p> required <code>image_dir</code> <code>str</code> <p>Directory path containing the TIFF images. Default is './'.</p> <code>'./'</code> <p>Returns:</p> Name Type Description <code>adata</code> <code>AnnData</code> <p>Anndata object with TIFF images inserted into the 'spatial' attribute under the 'uns' category.</p>"},{"location":"API%20Reference/function/labeltransfer/","title":"Labeltransfer","text":""},{"location":"API%20Reference/function/labeltransfer/#stpipe.labeltransfer","title":"<code>stpipe.labeltransfer(adata, bdata, celltype='celltype')</code>","text":"<p>Transfer cell type labels from scRNA-seq to Spatial transcriptomics data using Scanorama.</p> <p>It performs batch correction using Scanorama on the combined datasets and computes the label transfer based on cosine distances between the corrected embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>AnnData object representing Spatial transcriptomics data.</p> required <code>bdata</code> <code>AnnData</code> <p>AnnData object representing scRNA-seq.</p> required <code>celltype</code> <code>str</code> <p>The key in the observation metadata of 'bdata' containing cell type labels. Default is 'celltype'.</p> <code>'celltype'</code> <p>Returns:</p> Name Type Description <code>adata_transfer</code> <code>AnnData</code> <p>AnnData object with transferred cell type labels. The transferred labels are stored in the observation metadata under the key 'labeltransfer_celltype'. Additionally, the maximum confidence score are stored in the observation metadata under the keys 'max_score'.</p>"},{"location":"API%20Reference/function/leiden/","title":"Leiden","text":""},{"location":"API%20Reference/function/leiden/#stpipe.function.leiden","title":"<code>stpipe.function.leiden(adata, resolution=1.0)</code>","text":"<p>Perform Leiden clustering on Anndata object.</p> <p>This function performs Leiden community detection on the given Anndata object's neighborhood graph.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Anndata object containing gene expression data.</p> required <code>resolution</code> <code>float</code> <p>Resolution parameter for controlling the granularity of the communities. Default is 1.0.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>adata</code> <code>AnnData</code> <p>Anndata object with Leiden community labels assigned to observations stored in the 'obs' attribute under the key 'leiden'.</p>"},{"location":"API%20Reference/function/lognormal/","title":"Lognormal","text":""},{"location":"API%20Reference/function/lognormal/#stpipe.function.lognormal","title":"<code>stpipe.function.lognormal(adata, scale_factor=10000, num_chunks=30)</code>","text":"<p>Apply log-normalization to the 'X' attribute.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An anndata object.</p> required <code>scale_factor</code> <code>float</code> <p>Scale factor for cell-level normalization (default:10000).</p> <code>10000</code> <code>num_chunks</code> <code>int</code> <p>Number of data chunks for parallel processing (default: 30).</p> <code>30</code> <p>Returns:</p> Name Type Description <code>adata</code> <code>AnnData</code> <p>A new anndata object with log-normalized data in the 'X' attribute.</p>"},{"location":"API%20Reference/function/metacell/","title":"Metacell","text":""},{"location":"API%20Reference/function/metacell/#stpipe.spatial_metacell.spatial_bigcells","title":"<code>stpipe.spatial_metacell.spatial_bigcells(adata, method='walktrap', n_pca=30, n_neighbors=200, n_jobs=4, distance_threshold=50, p=5, resolution=1, celltypes='celltype', nb_trials=1, weights=None, const=1, a=50, sigma=10, b=10, node_weight=None)</code>","text":"<p>Detect spatial metacell using network-based clustering algorithms.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An AnnData object representing the Spatial transcriptomics data.</p> required <code>method</code> <code>str</code> <p>The clustering method to use. Options are 'walktrap', 'edge_betweenness', 'leiden', 'multilevel', and 'infomap'.</p> <code>'walktrap'</code> <code>n_pca</code> <code>int</code> <p>Number of principal components to use for dimensionality reduction.</p> <code>30</code> <code>n_neighbors</code> <code>int</code> <p>Number of neighbors to consider for constructing the k-nearest neighbor graph.</p> <code>200</code> <code>n_jobs</code> <code>int</code> <p>Number of parallel jobs to run for k-nearest neighbor search.</p> <code>4</code> <code>distance_threshold</code> <code>int or None</code> <p>Threshold distance for filtering out distant neighbors.</p> <code>50</code> <code>p</code> <code>int</code> <p>For method is walktrap or edge_betweenness. The desired number of cells per metacell.</p> <code>5</code> <code>nb_trials</code> <code>int</code> <p>For method is infomap.The number of attempts to partition the network (can be any integer value equal or larger than 1).</p> <code>1</code> <code>resolution</code> <code>float</code> <p>For method is multilevel or leiden. Default is 1.</p> <code>1</code> <code>celltypes</code> <code>str</code> <p>Key in the observation metadata containing cell type annotations. Default is 'celltype'.</p> <code>'celltype'</code> <code>weights</code> <code>str or None</code> <p>Method for assigning weights to edges in the graph. Options are 'inverse_distance', 'gaussian', 'celltype', or None. Default is None.</p> <code>None</code> <code>const</code> <code>int</code> <p>Constant value for inverse distance weighting.</p> <code>1</code> <code>a</code> <code>int</code> <p>Parameter for inverse distance weighting.</p> <code>50</code> <code>sigma</code> <code>int</code> <p>Standard deviation parameter for Gaussian weighting.</p> <code>10</code> <code>b</code> <code>int</code> <p>Weight for edges based on cell type similarity.</p> <code>10</code> <code>node_weight</code> <code>str or None</code> <p>Key in the observation metadata containing node weights.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>adata</code> <code>AnnData</code> <p>An updated AnnData object with metacell assignments stored in the observation metadata under the key 'membership'.</p> <code>clusters</code> <code>VertexClustering</code> <p>A vertex clustering object representing the detected meta cell.</p>"},{"location":"API%20Reference/function/pca/","title":"Pca","text":""},{"location":"API%20Reference/function/pca/#stpipe.function.PCA","title":"<code>stpipe.function.PCA(adata, n_components=50, random_state=42, method='pca')</code>","text":"<p>Perform Principal Component Analysis (PCA) on  anndata.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An anndata object.</p> required <code>n_components</code> <code>Union[None, int, float]) </code> <p>Number of PCs to be returned. When n_components is set &gt;0, the specified number of PCs is returned. When n_components is set between [0..1], the number of PCs is returned that covers at least this percentage of variance. for example: n_components=None means return all PCs. n_components=0.95 means return the number of PCs that cover at least 95% of variance. n_components=3 means return the top 3 PCs.</p> <code>50</code> <code>random_state</code> <code>int or None</code> <p>Seed for random number generation (default: 42).</p> <code>42</code> <code>method</code> <code>str</code> <p>The method used for PCA. 'pca' means Principal Component Analysis. 'sparse_pca' means Sparse Principal Components Analysis. 'trunc_svd' means truncated SVD (aka LSA).</p> <code>'pca'</code> <p>Returns:</p> Name Type Description <code>adata</code> <code>AnnData</code> <p>A new anndata object with PCA results stored in the 'obsm' and 'varm' attributes.</p>"},{"location":"API%20Reference/function/qc/","title":"Qc","text":""},{"location":"API%20Reference/function/qc/#stpipe.QC","title":"<code>stpipe.QC</code>","text":""},{"location":"API%20Reference/function/qc/#stpipe.QC.additional_seq_vs_seq","title":"<code>additional_seq_vs_seq(adata1, adata2, min_genes_list=list(range(0, 800, 100)), image_width=5, image_height=5, xlabel='min_genes', slice='id', min_cells=3, ylabel='valid cells P.', title='sequencing vs additional sequencing', slice_id=None, color='blue', s=15, o=None)</code>","text":"<p>Create a scatter plot to compare the percentage of valid cells in sequencing data and additional sequencing data.</p> <p>Parameters:</p> Name Type Description Default <code>adata1</code> <code>AnnData</code> <p>An AnnData object representing the sequencing data.</p> required <code>adata2</code> <code>AnnData</code> <p>An AnnData object representing the additional sequencing data.</p> required <code>min_genes_list</code> <code>list</code> <p>A list of minimum gene counts for cell filtering. Default is a list from 0 to 800 with a step of 100.</p> <code>list(range(0, 800, 100))</code> <code>image_width</code> <code>int</code> <p>Width of the generated image. Default is 5.</p> <code>5</code> <code>image_height</code> <code>int</code> <p>Height of the generated image. Default is 5.</p> <code>5</code> <code>xlabel</code> <code>str</code> <p>Label for the X-axis. Default is 'min_genes'.</p> <code>'min_genes'</code> <code>slice</code> <code>str</code> <p>Column in the observation data used for grouping slices.</p> <code>'id'</code> <code>min_cells</code> <code>int</code> <p>min_cells to filter genes.</p> <code>3</code> <code>ylabel</code> <code>str</code> <p>Label for the Y-axis. Default is 'valid cells P.'.</p> <code>'valid cells P.'</code> <code>title</code> <code>str</code> <p>Title of the plot. Default is 'sequencing vs additional sequencing'.</p> <code>'sequencing vs additional sequencing'</code> <code>slice_id</code> <code>str</code> <p>The ID of the slice to analyze.</p> <code>None</code> <code>color</code> <code>str</code> <p>Color for the scatter plot markers. Default is 'blue'.</p> <code>'blue'</code> <code>s</code> <code>int</code> <p>Size of the scatter plot markers. Default is 15.</p> <code>15</code> <code>o</code> <code>str</code> <p>Path and filename for saving the image. If not provided, the image will not be saved.</p> <code>None</code>"},{"location":"API%20Reference/function/qc/#stpipe.QC.cell_numbers_by_min_genes","title":"<code>cell_numbers_by_min_genes(adata, min_genes_list=list(range(0, 1400, 50)), image_width=5, image_height=5, xlabel='min_genes', ylabel='cell number', title=None, o=None, **kwargs)</code>","text":"<p>Create a line plot reflecting the number of cells remaining after filtering with different min_genes</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An AnnData object.</p> required <code>min_genes_list</code> <code>list</code> <p>List of minimum gene counts used for filtering cells. Default list(range(0, 1400, 50)).</p> <code>list(range(0, 1400, 50))</code> <code>image_width</code> <code>int</code> <p>Width of the generated plot image. Default is 5.</p> <code>5</code> <code>image_height</code> <code>int</code> <p>Height of the generated plot image. Default is 5.</p> <code>5</code> <code>xlabel</code> <code>str</code> <p>Label for the X-axis of the plot. Default is 'min_genes'.</p> <code>'min_genes'</code> <code>ylabel</code> <code>str</code> <p>Label for the Y-axis of the plot. Default is 'cell number'.</p> <code>'cell number'</code> <code>title</code> <code>str</code> <p>Title of the plot. If not provided, no title will be displayed.</p> <code>None</code> <code>o</code> <code>str</code> <p>Path and filename for saving the plot image. If not provided, the image will not be saved.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the plt.plot function.</p> <code>{}</code>"},{"location":"API%20Reference/function/qc/#stpipe.QC.detect_markers_by_filter_cells","title":"<code>detect_markers_by_filter_cells(adata, markers, min_genes_list=list(range(0, 1400, 50)), min_cells_list=[3], image_width=5, image_height=5, xlabel='min_genes', ylabel='Percentage', title='Percentage of markers remaining', o=None, **kwargs)</code>","text":"<p>Create a line plot that shows how many of the marker genes are still present in the adata after filtering, as you change the min_genes and the min_cells used for filtering.(The proportion of marker genes in markers)</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An AnnData object.</p> required <code>markers</code> <code>list</code> <p>A list of marker gene names.</p> required <code>min_genes_list</code> <code>list</code> <p>A list of min_genes to consider. Default list(range(0, 1400, 50)).</p> <code>list(range(0, 1400, 50))</code> <code>min_cells_list</code> <code>list</code> <p>A list of min_cells for gene filtering. Default [3].</p> <code>[3]</code> <code>image_width</code> <code>int</code> <p>Width of the generated image. Default is 5.</p> <code>5</code> <code>image_height</code> <code>int</code> <p>Height of the generated image. Default is 5.</p> <code>5</code> <code>xlabel</code> <code>str</code> <p>Label for the X-axis. Default is 'min_genes'.</p> <code>'min_genes'</code> <code>ylabel</code> <code>str</code> <p>Label for the Y-axis. Default is 'Percentage'.</p> <code>'Percentage'</code> <code>title</code> <code>str</code> <p>Title of the plot. Default is 'Percentage of markers remaining'.</p> <code>'Percentage of markers remaining'</code> <code>o</code> <code>str</code> <p>Path and filename for saving the image. If not provided, the image will not be saved.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the plt.plot function.</p> <code>{}</code>"},{"location":"API%20Reference/function/qc/#stpipe.QC.detect_markers_by_filter_cells2","title":"<code>detect_markers_by_filter_cells2(adata, markers, min_genes_list=list(range(0, 1400, 50)), min_cells_list=[3], image_width=5, image_height=5, xlabel='min_genes', ylabel='Percentage', title='Percentage of markers detected', o=None, **kwargs)</code>","text":"<p>Create a line plot that shows how many of the marker genes are still present in the adata after filtering, as you change the min_genes and the min_cells used for filtering.(The proportion of marker genes in adata)</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An AnnData object.</p> required <code>markers</code> <code>list</code> <p>A list of marker gene names.</p> required <code>min_genes_list</code> <code>list</code> <p>List of minimum gene counts for filtering. Default list(range(0, 1400, 50)).</p> <code>list(range(0, 1400, 50))</code> <code>min_cells_list</code> <code>list</code> <p>List of minimum cell counts for filtering. Default is [3].</p> <code>[3]</code> <code>image_width</code> <code>int</code> <p>Width of the generated image. Default is 5.</p> <code>5</code> <code>image_height</code> <code>int</code> <p>Height of the generated image. Default is 5.</p> <code>5</code> <code>xlabel</code> <code>str</code> <p>Label for the X-axis. Default is 'min_genes'.</p> <code>'min_genes'</code> <code>ylabel</code> <code>str</code> <p>Label for the Y-axis. Default is 'Percentage'.</p> <code>'Percentage'</code> <code>title</code> <code>str</code> <p>Title of the plot. Default is 'Percentage of markers detected'.</p> <code>'Percentage of markers detected'</code> <code>o</code> <code>str</code> <p>Path and filename for saving the image. If not provided, the image will not be saved.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the plt.plot function.</p> <code>{}</code>"},{"location":"API%20Reference/function/qc/#stpipe.QC.markers_detected_by_diff_ngenes_bar","title":"<code>markers_detected_by_diff_ngenes_bar(adata, markers, bin=50, image_width=12, image_height=6, xlabel='n_genes', ylabel='Markers detection rate', title=None, o=None, **kwargs)</code>","text":"<p>Create a bar plot to visualize the relationship between the number of genes (n_genes) and the detection rate of markers.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An AnnData object.</p> required <code>markers</code> <code>list</code> <p>A list of marker gene names.</p> required <code>bin</code> <code>int</code> <p>The bin size for grouping n_genes values. Default is 50.</p> <code>50</code> <code>image_width</code> <code>int</code> <p>Width of the generated image. Default is 12.</p> <code>12</code> <code>image_height</code> <code>int</code> <p>Height of the generated image. Default is 6.</p> <code>6</code> <code>xlabel</code> <code>str</code> <p>Label for the X-axis. Default is 'n_genes'.</p> <code>'n_genes'</code> <code>ylabel</code> <code>str</code> <p>Label for the Y-axis. Default is 'Markers detection rate'.</p> <code>'Markers detection rate'</code> <code>title</code> <code>str</code> <p>Title of the plot. If not provided, no title is displayed.</p> <code>None</code> <code>o</code> <code>str</code> <p>Path and filename for saving the image. If not provided, the image will not be saved.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the plt.bar function.</p> <code>{}</code>"},{"location":"API%20Reference/function/qc/#stpipe.QC.markers_detected_by_diff_ngenes_scatter","title":"<code>markers_detected_by_diff_ngenes_scatter(adata, markers, image_width=6, image_height=6, xlabel='n_genes', ylabel='Markers detection rate', title=None, o=None, **kwargs)</code>","text":"<p>Create a scatter plot to visualize the relationship between the number of genes (n_genes) and the detection rate of markers.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An AnnData object.</p> required <code>markers</code> <code>list</code> <p>A list of marker gene names.</p> required <code>image_width</code> <code>int</code> <p>Width of the generated image. Default is 6.</p> <code>6</code> <code>image_height</code> <code>int</code> <p>Height of the generated image. Default is 6.</p> <code>6</code> <code>xlabel</code> <code>str</code> <p>Label for the X-axis. Default is 'n_genes'.</p> <code>'n_genes'</code> <code>ylabel</code> <code>str</code> <p>Label for the Y-axis. Default is 'Markers detection rate'.</p> <code>'Markers detection rate'</code> <code>title</code> <code>str</code> <p>Title of the plot. If not provided, no title is displayed.</p> <code>None</code> <code>o</code> <code>str</code> <p>Path and filename for saving the image. If not provided, the image will not be saved.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the plt.scatter function.</p> <code>{}</code>"},{"location":"API%20Reference/function/qc/#stpipe.QC.valid_cells_per_slice","title":"<code>valid_cells_per_slice(adata, min_genes_list=list(range(0, 800, 100)), image_width=5, image_height=5, xlabel='min_genes', slice='id', library='current object', median_n_genes=[], ylabel='Percentage', title='Percentage of markers detected', o=None, **kwargs)</code>","text":"<p>Create line plots to illustrate the relationship between the library median n_genes and the percentage of valid cells per slice.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An AnnData object.</p> required <code>min_genes_list</code> <code>list</code> <p>A list of minimum gene counts for cell filtering. Default is a list from 0 to 800 with a step of 100.</p> <code>list(range(0, 800, 100))</code> <code>image_width</code> <code>int</code> <p>Width of the generated image. Default is 5.</p> <code>5</code> <code>image_height</code> <code>int</code> <p>Height of the generated image. Default is 5.</p> <code>5</code> <code>xlabel</code> <code>str</code> <p>Label for the X-axis. Default is 'min_genes'.</p> <code>'min_genes'</code> <code>slice</code> <code>str</code> <p>Column in the observation data used for grouping slices and analyzing the percentage of valid cells.</p> <code>'id'</code> <code>library</code> <code>str</code> <p>Source of data for calculating the median number of genes per slice. Default is 'current object', using the observation data of the current object. Alternatively, provide a list 'median_n_genes' as reference.</p> <code>'current object'</code> <code>median_n_genes</code> <code>list</code> <p>If 'library' is not 'current object', provide a list of Library median gene counts as reference.</p> <code>[]</code> <code>ylabel</code> <code>str</code> <p>Label for the Y-axis. Default is 'Percentage'.</p> <code>'Percentage'</code> <code>title</code> <code>str</code> <p>Title of the plot. Default is 'Percentage of markers detected'.</p> <code>'Percentage of markers detected'</code> <code>o</code> <code>str</code> <p>Path and filename for saving the image. If not provided, the image will not be saved.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the sns.regplot function.</p> <code>{}</code>"},{"location":"API%20Reference/function/scale/","title":"Scale","text":""},{"location":"API%20Reference/function/scale/#stpipe.function.scale","title":"<code>stpipe.function.scale(adata, centering=True, max_value=10)</code>","text":"<p>Scale the expression values of genes.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An anndata object.</p> required <code>centering</code> <code>bool</code> <p>Whether to center the data (default: True). If True, the data is centered by subtracting the mean expression of each gene. If False, only scaling is performed.</p> <code>True</code> <code>max_value</code> <code>float or None</code> <p>Maximum value for scaled data (default: 10). If provided, the scaled values are clipped to this maximum value.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>adata</code> <code>AnnData</code> <p>A new anndata object with scaled gene expression values in the 'X' attribute.</p>"},{"location":"API%20Reference/function/svg/","title":"Svg","text":""},{"location":"API%20Reference/function/svg/#stpipe.function.svg","title":"<code>stpipe.function.svg(adata, n_top_genes=2000, mode='moran_geary', n_neighbors=30)</code>","text":"<p>Perform spatially variable gene analysis (SVG) on Anndata object.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Anndata object containing spatial gene expression data.</p> required <code>n_top_genes</code> <code>int</code> <p>Number of top genes to select as spatially variable genes. Default is 2000.</p> <code>2000</code> <code>mode</code> <code>str</code> <p>Mode for SVG analysis. Options are 'moran_geary', 'moran' or 'geary'. Default is 'moran_geary'.</p> <code>'moran_geary'</code> <code>n_neighbors</code> <code>int</code> <p>Number of nearest neighbors used to construct the spatial neighbor graph. Default is 30.</p> <code>30</code> <p>Returns:</p> Name Type Description <code>adata</code> <code>AnnData</code> <p>Anndata object with spatially variable genes identified and stored in the 'var' attribute.</p>"},{"location":"API%20Reference/function/tsne/","title":"Tsne","text":""},{"location":"API%20Reference/function/tsne/#stpipe.function.tsne","title":"<code>stpipe.function.tsne(adata, input=15, perplexity=30, learning_rate='auto', random_seed=42, early_exaggeration=12, metric='euclidean', n_jobs=1, **kwargs)</code>","text":"<p>Perform t-distributed Stochastic Neighbor Embedding (t-SNE) dimensionality reduction on Spatial transcriptomics data.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An anndata object.</p> required <code>input</code> <code>int or str</code> <p>(default: 15). If an integer, it specifies the number of principal components from PCA to use as input for t-SNE. If a string, it can be the name of an existing 'obsm' field in the AnnData object to use as input. If the string does not correspond to an existing field, the function falls back to using the adata.X.</p> <code>15</code> <code>perplexity</code> <code>float</code> <p>Perplexity parameter for t-SNE (default: 30). Perplexity can be thought of as the continuous :math:<code>k</code> number of nearest neighbors, for which t-SNE will attempt to preserve distances.</p> <code>30</code> <code>learning_rate</code> <code>(str, float)</code> <p>Learning rate for t-SNE optimization (default: 'auto'). The learning rate for t-SNE optimization. When <code>learning_rate=\"auto\"</code> the appropriate learning rate is selected according to max(200, N / 12), as determined in Belkina et al. \"Automated optimized parameters for T-distributed stochastic neighbor embedding improve visualization and analysis of large datasets\", 2019.</p> <code>'auto'</code> <code>random_seed</code> <code>(int, RandomState)</code> <p>Seed for random number generation (default: 42). If the value is an int, random_state is the seed used by the random number generator. If the value is a RandomState instance, then it will be used as the random number generator. If the value is None, the random number generator is the RandomState instance used by <code>np.random</code>.</p> <code>42</code> <code>early_exaggeration</code> <code>float</code> <p>Early exaggeration parameter for t-SNE (default: 12). Early exaggeration increases attractive forces between data points in the initial embedding.</p> <code>12</code> <code>metric</code> <code>str</code> <p>Distance metric for t-SNE (default: 'euclidean'). The distance metric used to measure pairwise distances between data points.</p> <code>'euclidean'</code> <code>n_jobs</code> <code>int</code> <p>The number of threads to use while running t-SNE. This follows the scikit-learn convention, <code>-1</code> meaning all processors, <code>-2</code> meaning all but one, etc.</p> <code>1</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for openTSNE</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>adata</code> <code>AnnData</code> <p>A new anndata object with t-SNE results stored in the 'obsm' attribute as 'X_tsne'.</p>"},{"location":"API%20Reference/function/vst_highly_variable_genes/","title":"Vst highly variable genes","text":""},{"location":"API%20Reference/function/vst_highly_variable_genes/#stpipe.function.vst_highly_variable_genes","title":"<code>stpipe.function.vst_highly_variable_genes(adata, n_top_genes=2000, span=0.3)</code>","text":"<p>Identify highly variable genes using the VST (Variance Stabilizing Transformation) method.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An anndata object.</p> required <code>n_top_genes</code> <code>int</code> <p>Number of highly variable genes to select (default: 2000).</p> <code>2000</code> <code>span</code> <code>float</code> <p>Span parameter for the LOESS regression (default: 0.3).</p> <code>0.3</code> <p>Returns:</p> Name Type Description <code>adata</code> <code>AnnData</code> <p>A new anndata object with added information about highly variable genes in the 'var' attribute.</p>"},{"location":"API%20Reference/plot/plot_function/","title":"plot","text":""},{"location":"API%20Reference/plot/plot_function/#stpipe.plot","title":"<code>stpipe.plot</code>","text":""},{"location":"API%20Reference/plot/plot_function/#stpipe.plot.metacell_purity","title":"<code>metacell_purity(adata, bins=20, color='skyblue', save=None, dpi=360, celltype='leiden', figsize=(8, 6))</code>","text":"<p>Plot the distribution of metacell purity.</p> <p>This function calculates the purity of each metacell based on the predominant cell type and plots the distribution of purities as a histogram along with a kernel density estimate (KDE) curve.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Annotated data object containing metacell information.</p> required <code>bins</code> <code>int</code> <p>Number of bins for the histogram. Defaults to 20.</p> <code>20</code> <code>color</code> <code>str</code> <p>Color of the histogram bars. Defaults to 'skyblue'.</p> <code>'skyblue'</code> <code>save</code> <code>str or None</code> <p>File path to save the plot. If None, the plot is not saved. Defaults to None.</p> <code>None</code> <code>dpi</code> <code>int</code> <p>Dots per inch for the saved figure. Defaults to 360.</p> <code>360</code> <code>celltype</code> <code>str</code> <p>Column name representing the cell type information in the AnnData object. Defaults to 'leiden'.</p> <code>'leiden'</code> <code>figsize</code> <code>tuple</code> <p>Size of the figure in inches (width, height). Defaults to (8, 6).</p> <code>(8, 6)</code>"},{"location":"API%20Reference/plot/plot_function/#stpipe.plot.metacell_size","title":"<code>metacell_size(adata, color='skyblue', bins=20, save=None, dpi=360, figsize=(8, 6))</code>","text":"<p>Plot the distribution of metacell sizes.</p> <p>This function plots a histogram of metacell sizes along with a kernel density estimate (KDE) curve.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>Annotated data object containing metacell information.</p> required <code>color</code> <code>str</code> <p>Color of the histogram bars. Defaults to 'skyblue'.</p> <code>'skyblue'</code> <code>bins</code> <code>int</code> <p>Number of bins for the histogram. Defaults to 20.</p> <code>20</code> <code>save</code> <code>str or None</code> <p>File path to save the plot. If None, the plot is not saved. Defaults to None.</p> <code>None</code> <code>dpi</code> <code>int</code> <p>Dots per inch for the saved figure. Defaults to 360.</p> <code>360</code> <code>figsize</code> <code>tuple</code> <p>Size of the figure in inches (width, height). Defaults to (8, 6).</p> <code>(8, 6)</code>"},{"location":"API%20Reference/plot/plot_function/#stpipe.plot.pca_variance_ratio","title":"<code>pca_variance_ratio(adata, color='brown', marker='o', markersize=4, figsize=(5, 4), dpi=360, xlabel='Number of PCs', ylabel='Variance ratio', title=None, save=None, log=False, npc=20)</code>","text":"<p>Plot the variance ratio of principal components obtained from PCA.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An AnnData object containing PCA results.</p> required <code>color</code> <code>str</code> <p>Color of the plot markers. Defaults to 'brown'.</p> <code>'brown'</code> <code>marker</code> <code>str</code> <p>Marker style for the plot. Defaults to 'o'.</p> <code>'o'</code> <code>markersize</code> <code>int</code> <p>Size of the plot markers. Defaults to 4.</p> <code>4</code> <code>figsize</code> <code>tuple</code> <p>Figure size in inches. Defaults to (5, 4).</p> <code>(5, 4)</code> <code>dpi</code> <code>int</code> <p>Dots per inch for the figure resolution. Defaults to 360.</p> <code>360</code> <code>xlabel</code> <code>str</code> <p>Label for the x-axis. Defaults to 'Number of PCs'.</p> <code>'Number of PCs'</code> <code>ylabel</code> <code>str</code> <p>Label for the y-axis. Defaults to 'Variance ratio'.</p> <code>'Variance ratio'</code> <code>title</code> <code>str</code> <p>Title for the plot. Defaults to None.</p> <code>None</code> <code>save</code> <code>str or None</code> <p>File path to save the plot. If None, the plot is not saved. Defaults to None.</p> <code>None</code> <code>log</code> <code>bool</code> <p>Whether to plot the variance ratio in log scale. Defaults to False.</p> <code>False</code> <code>npc</code> <code>int</code> <p>Number of principal components to include in the plot. Defaults to 20.</p> <code>20</code>"},{"location":"API%20Reference/plot/plot_function/#stpipe.plot.plot_cellcount_between_ref_query","title":"<code>plot_cellcount_between_ref_query(adata_query, adata_ref, key1='labeltransfer_celltype', key2='celltype', figsize=(12, 5), xrotation=45, xha='right', save=None, title1='scRNA-seq', title2='St', dpi=360)</code>","text":"<p>Plot cell count comparison between reference and query datasets.</p> <p>This function plots a bar chart comparing the cell counts of different cell types between a reference dataset and a query dataset.</p> <p>Parameters:</p> Name Type Description Default <code>adata_query</code> <code>AnnData</code> <p>An AnnData object representing the query dataset.</p> required <code>adata_ref</code> <code>AnnData</code> <p>An AnnData object representing the reference dataset.</p> required <code>key1</code> <code>str</code> <p>Key in adata_query.obs representing the cell type information. Defaults to 'labeltransfer_celltype'.</p> <code>'labeltransfer_celltype'</code> <code>key2</code> <code>str</code> <p>Key in adata_ref.obs representing the cell type information. Defaults to 'celltype'.</p> <code>'celltype'</code> <code>figsize</code> <code>tuple</code> <p>Size of the figure in inches (width, height). Defaults to (12, 5).</p> <code>(12, 5)</code> <code>xrotation</code> <code>int</code> <p>Rotation angle for x-axis tick labels. Defaults to 45.</p> <code>45</code> <code>xha</code> <code>str</code> <p>Horizontal alignment of x-axis tick labels. Defaults to 'right'.</p> <code>'right'</code> <code>save</code> <code>str or None</code> <p>File path to save the plot. If None, the plot is not saved. Defaults to None.</p> <code>None</code> <code>title1</code> <code>str</code> <p>Title for the query dataset plot. Defaults to 'scRNA-seq'.</p> <code>'scRNA-seq'</code> <code>title2</code> <code>str</code> <p>Title for the reference dataset plot. Defaults to 'St'.</p> <code>'St'</code> <code>dpi</code> <code>int</code> <p>Dots per inch for the saved figure. Defaults to 360.</p> <code>360</code>"},{"location":"API%20Reference/plot/plot_function/#stpipe.plot.plot_labeltransfer_score_distribution","title":"<code>plot_labeltransfer_score_distribution(adata_transfer, bar_color='skyblue', figsize=(8, 6), save=None, xrotation=0, dpi=360)</code>","text":"<p>Plot the distribution of label transfer maximum scores.</p> <p>This function plots the distribution of maximum scores obtained during the label transfer process.</p> <p>Parameters:</p> Name Type Description Default <code>adata_transfer</code> <code>AnnData</code> <p>An AnnData object containing the label transfer results.</p> required <code>bar_color</code> <code>str</code> <p>Color of the bars in the histogram. Defaults to 'skyblue'.</p> <code>'skyblue'</code> <code>figsize</code> <code>tuple</code> <p>Size of the figure in inches (width, height). Defaults to (8, 6).</p> <code>(8, 6)</code> <code>save</code> <code>str or None</code> <p>File path to save the plot. If None, the plot is not saved. Defaults to None.</p> <code>None</code> <code>xrotation</code> <code>float</code> <p>Rotation angle for x-axis tick labels. Defaults to 0.</p> <code>0</code> <code>dpi</code> <code>int</code> <p>Dots per inch for the figure resolution. Defaults to 360.</p> <code>360</code>"},{"location":"API%20Reference/plot/plot_function/#stpipe.plot.plot_labeltransfer_score_violin","title":"<code>plot_labeltransfer_score_violin(adata_transfer, groupby='id', inner=None, save=None, figsize=(8, 5), xrotation=90, xha='right', color='blue')</code>","text":"<p>Plot a violin plot of label transfer maximum scores.</p> <p>This function plots a violin plot of maximum scores obtained during the label transfer process grouped by a specified category.</p> <p>Parameters:</p> Name Type Description Default <code>adata_transfer</code> <code>AnnData</code> <p>An AnnData object containing the label transfer results.</p> required <code>groupby</code> <code>str</code> <p>Key in adata_transfer.obs specifying the category by which to group the scores. Defaults to 'id'.</p> <code>'id'</code> <code>inner</code> <code>str or None</code> <p>Type of data representation inside the violins. Defaults to None.</p> <code>None</code> <code>save</code> <code>str or None</code> <p>File path to save the plot. If None, the plot is not saved. Defaults to None.</p> <code>None</code> <code>figsize</code> <code>tuple</code> <p>Size of the figure in inches (width, height). Defaults to (8, 5).</p> <code>(8, 5)</code> <code>xrotation</code> <code>int</code> <p>Rotation angle for x-axis tick labels. Defaults to 90.</p> <code>90</code> <code>xha</code> <code>str</code> <p>Horizontal alignment of x-axis tick labels. Defaults to 'right'.</p> <code>'right'</code> <code>color</code> <code>str</code> <p>Color of the violins. Defaults to 'blue'.</p> <code>'blue'</code>"},{"location":"API%20Reference/plot/plot_function/#stpipe.plot.plot_marker_dotplot","title":"<code>plot_marker_dotplot(cdata, genes=[], groupby='leiden', figsize=(10, 8), vmin=0, vmax=3, cmap='viridis', rotation=0, save=None, dpi=360)</code>","text":"<p>Generate a marker dot plot to visualize gene expression across cell clusters.</p> <p>This function generates a marker dot plot to visualize the expression of marker genes across different cell clusters. Each dot in the plot represents a cell cluster, and the color and size of the dot indicate the average expression level and percentage of cells expressing the marker gene, respectively.</p> <p>Parameters:</p> Name Type Description Default <code>cdata</code> <code>AnnData</code> <p>An AnnData object containing the data.</p> required <code>genes</code> <code>list</code> <p>List of marker genes to include in the dot plot.</p> <code>[]</code> <code>groupby</code> <code>str</code> <p>Name of the category column in cdata.obs to group cells by. Defaults to 'leiden'.</p> <code>'leiden'</code> <code>figsize</code> <code>tuple</code> <p>Size of the figure in inches (width, height). Defaults to (10, 8).</p> <code>(10, 8)</code> <code>vmin</code> <code>float</code> <p>Minimum value for color normalization. Defaults to 0.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>Maximum value for color normalization. Defaults to 3.</p> <code>3</code> <code>cmap</code> <code>str</code> <p>Colormap name for coloring the dots. Defaults to 'viridis'.</p> <code>'viridis'</code> <code>rotation</code> <code>int</code> <p>Rotation angle for cluster labels on the x-axis. Defaults to 0.</p> <code>0</code> <code>save</code> <code>str or None</code> <p>File path to save the plot. If None, the plot is not saved. Defaults to None.</p> <code>None</code> <code>dpi</code> <code>int</code> <p>Dots per inch for the figure resolution. Defaults to 360.</p> <code>360</code>"},{"location":"API%20Reference/plot/plot_function/#stpipe.plot.plot_marker_heatmap","title":"<code>plot_marker_heatmap(cdata, use_raw=True, genes=[], groupby='leiden', z_score=None, figsize=(10, 10), vmin=None, vmax=None, save=None, cmap='viridis', standard_scale=None, rotation=0, dpi=360)</code>","text":"<p>Generate a marker heatmap plot for visualizing gene expression across cell clusters.</p> <p>This function generates a marker heatmap plot to visualize the expression of marker genes across different cell clusters. Each row in the heatmap represents a marker gene, and each column represents a cell cluster. The color intensity of each cell in the heatmap indicates the expression level of the corresponding marker gene in the respective cell cluster.</p> <p>Parameters:</p> Name Type Description Default <code>cdata</code> <code>AnnData</code> <p>An AnnData object containing the data.</p> required <code>use_raw</code> <code>bool</code> <p>Whether to use raw.X instead of .X for gene expression. Defaults to True.</p> <code>True</code> <code>genes</code> <code>list</code> <p>List of marker genes to include in the heatmap. Defaults to an empty list.</p> <code>[]</code> <code>groupby</code> <code>str</code> <p>Name of the category column in cdata.obs to group cells by. Defaults to 'leiden'.</p> <code>'leiden'</code> <code>z_score</code> <code>int or None</code> <p>Whether to z-score normalize the expression values. If None, no normalization is applied.                    Defaults to None.</p> <code>None</code> <code>figsize</code> <code>tuple</code> <p>Size of the figure in inches (width, height). Defaults to (10, 10).</p> <code>(10, 10)</code> <code>vmin</code> <code>float or None</code> <p>Minimum value for color normalization. If None, the minimum value in the data is used.                   Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float or None</code> <p>Maximum value for color normalization. If None, the maximum value in the data is used.                   Defaults to None.</p> <code>None</code> <code>save</code> <code>str or None</code> <p>File path to save the plot. If None, the plot is not saved. Defaults to None.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Colormap name for coloring the heatmap. Defaults to 'viridis'.</p> <code>'viridis'</code> <code>standard_scale</code> <code>int or None</code> <p>Whether to standard scale the expression values along the rows or columns. If None,                           no scaling is applied. Defaults to None.</p> <code>None</code> <code>rotation</code> <code>int</code> <p>Rotation angle for cluster labels on the x-axis. Defaults to 0.</p> <code>0</code> <code>dpi</code> <code>int</code> <p>Dots per inch for the figure resolution. Defaults to 360.</p> <code>360</code> <p>Returns:</p> Type Description <code>ClusterGrid</code> <p>A ClusterGrid object representing the marker heatmap plot.</p>"},{"location":"API%20Reference/plot/plot_function/#stpipe.plot.plot_moran","title":"<code>plot_moran(moran1, moran2, figsize=(5, 5), s=2, anno=None, save=None, dpi=360)</code>","text":"<p>Plot Moran scatter plot between two datasets.</p> <p>This function plots a Moran scatter plot between two datasets. It visualizes the Moran scores of common genes shared between the two datasets.</p> <p>Parameters:</p> Name Type Description Default <code>moran1</code> <code>Series</code> <p>Moran scores for the first dataset.</p> required <code>moran2</code> <code>Series</code> <p>Moran scores for the second dataset.</p> required <code>figsize</code> <code>tuple</code> <p>Size of the figure in inches (width, height). Defaults to (5, 5).</p> <code>(5, 5)</code> <code>s</code> <code>int</code> <p>Marker size. Defaults to 2.</p> <code>2</code> <code>anno</code> <code>list or None</code> <p>List of gene names to annotate on the plot. If None, no annotations are added. Defaults to None.</p> <code>None</code> <code>save</code> <code>str or None</code> <p>File path to save the plot. If None, the plot is not saved. Defaults to None.</p> <code>None</code> <code>dpi</code> <code>int</code> <p>Dots per inch for the saved figure. Defaults to 360.</p> <code>360</code>"},{"location":"API%20Reference/plot/plot_function/#stpipe.plot.plot_spatial","title":"<code>plot_spatial(adata, by=None, s=5, cmap=None, savefig=None, dpi=360, figsize=(6, 6), tiff=None, coord='spatial', title=None, legend=False, categorical=False, legend_title=True)</code>","text":"<p>Plot spatial information from Spatial transcriptomics data.</p> <p>This function visualizes spatial information for Spatial transcriptomics data. It can display cell coordinates on an image, with the option to color cells based on a specified category or gene expression level.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An AnnData object containing the spatial data.</p> required <code>by</code> <code>str or None</code> <p>Name of the category column in adata.obs to group cells by, or name of the gene for coloring               cells based on gene expression. Defaults to None.</p> <code>None</code> <code>s</code> <code>float</code> <p>Size of the markers representing cells. Defaults to 5.</p> <code>5</code> <code>cmap</code> <code>str or None</code> <p>Colormap for coloring cells. Defaults to None, which uses the 'viridis' colormap.</p> <code>None</code> <code>savefig</code> <code>str or None</code> <p>File path to save the plot. If None, the plot is not saved. Defaults to None.</p> <code>None</code> <code>dpi</code> <code>int</code> <p>Dots per inch for the figure resolution. Defaults to 360.</p> <code>360</code> <code>figsize</code> <code>tuple</code> <p>Size of the figure in inches (width, height). Defaults to (6, 6).</p> <code>(6, 6)</code> <code>tiff</code> <code>str or None</code> <p>Name of the TIFF file in adata.uns['spatial'] to overlay on the plot. Defaults to None.</p> <code>None</code> <code>coord</code> <code>str</code> <p>Key in adata.obsm containing the spatial coordinates. Defaults to 'spatial'.</p> <code>'spatial'</code> <code>title</code> <code>str or None</code> <p>Title for the plot. Defaults to None.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Whether to display the legend. Defaults to False.</p> <code>False</code> <code>categorical</code> <code>bool</code> <p>If True, color cells based on the specified category. If False, color cells based on gene                 expression. Defaults to False.</p> <code>False</code> <code>legend_title</code> <code>bool</code> <p>Title for the legend. Defaults to True.</p> <code>True</code>"},{"location":"API%20Reference/plot/plot_function/#stpipe.plot.plot_tsne","title":"<code>plot_tsne(adata, by=None, s=5, cmap=None, savefig=None, dpi=360, figsize=(6, 6))</code>","text":"<p>Generate a t-SNE plot for visualizing high-dimensional data.</p> <p>This function generates a t-SNE plot to visualize high-dimensional data in two dimensions. Data points are represented as scatter points on the plot, with optional coloring by a specified category or gene expression level.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An AnnData object containing the data.</p> required <code>by</code> <code>str or None</code> <p>Name of the category column in adata.obs or a gene name in adata.var_names to color the plot               by. Defaults to None.</p> <code>None</code> <code>s</code> <code>int</code> <p>Marker size for data points. Defaults to 5.</p> <code>5</code> <code>cmap</code> <code>str or None</code> <p>Colormap name for coloring the plot. If None, 'viridis' colormap is used. Defaults to None.</p> <code>None</code> <code>savefig</code> <code>str or None</code> <p>File path to save the plot. If None, the plot is not saved. Defaults to None.</p> <code>None</code> <code>dpi</code> <code>int</code> <p>Dots per inch for the figure resolution. Defaults to 360.</p> <code>360</code> <code>figsize</code> <code>tuple</code> <p>Size of the figure in inches (width, height). Defaults to (6, 6).</p> <code>(6, 6)</code>"},{"location":"API%20Reference/plot/plot_function/#stpipe.plot.spatial_bigcell_plot","title":"<code>spatial_bigcell_plot(adata, ncol=1, s=15, figsize=(7, 7), line_color='red', linewidth=1, xlabel='X', ylabel='Y', title=None, save=None, dpi=360, spatial_bigcell_key='membership', color_key='color', color_key_obs='leiden')</code>","text":"<p>Plot the spatial distribution of cells with highlighted spatial metacells.</p> <p>This function visualizes the spatial distribution of cells and highlights spatial metacells using convex hulls.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An AnnData object containing spatial coordinates and membership information.</p> required <code>ncol</code> <code>int</code> <p>Number of columns for the legend. Defaults to 1.</p> <code>1</code> <code>s</code> <code>int</code> <p>Marker size for individual cells. Defaults to 15.</p> <code>15</code> <code>figsize</code> <code>tuple</code> <p>Figure size in inches. Defaults to (7, 7).</p> <code>(7, 7)</code> <code>line_color</code> <code>str</code> <p>Color of the convex hull lines. Defaults to 'red'.</p> <code>'red'</code> <code>linewidth</code> <code>int</code> <p>Line width of the convex hull lines. Defaults to 1.</p> <code>1</code> <code>xlabel</code> <code>str</code> <p>Label for the x-axis. Defaults to 'X'.</p> <code>'X'</code> <code>ylabel</code> <code>str</code> <p>Label for the y-axis. Defaults to 'Y'.</p> <code>'Y'</code> <code>title</code> <code>str</code> <p>Title for the plot. Defaults to None.</p> <code>None</code> <code>save</code> <code>str or None</code> <p>File path to save the plot. If None, the plot is not saved. Defaults to None.</p> <code>None</code> <code>dpi</code> <code>int</code> <p>Dots per inch for the figure resolution. Defaults to 360.</p> <code>360</code> <code>spatial_bigcell_key</code> <code>str</code> <p>Key in adata.obs representing spatial big cell membership. Defaults to 'membership'.</p> <code>'membership'</code> <code>color_key</code> <code>str</code> <p>Key in adata.obs representing the color of individual cells. Defaults to 'color'.</p> <code>'color'</code> <code>color_key_obs</code> <code>str</code> <p>Key in adata.obs representing the color for the legend. Defaults to 'leiden'.</p> <code>'leiden'</code>"},{"location":"API%20Reference/plot/plot_function/#stpipe.plot.variable_plot","title":"<code>variable_plot(adata, cols=('black', 'red'), figsize=(6, 6), save=None, log=False, s=1, annotate_genes=None, legend_loc='best', dpi=360, anno_fontsize=10)</code>","text":"<p>Generate a variable feature plot to visualize mean expression versus variance of genes.</p> <p>This function generates a variable feature plot to visualize the relationship between mean expression and variance of genes. Highly variable genes are highlighted in a different color.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An AnnData object containing the data.</p> required <code>cols</code> <code>tuple</code> <p>Colors to use for plotting non-highly variable genes and highly variable genes, respectively.           Defaults to ('black', 'red').</p> <code>('black', 'red')</code> <code>figsize</code> <code>tuple</code> <p>Size of the figure in inches (width, height). Defaults to (6, 6).</p> <code>(6, 6)</code> <code>save</code> <code>str or None</code> <p>File path to save the plot. If None, the plot is not saved. Defaults to None.</p> <code>None</code> <code>log</code> <code>bool</code> <p>Whether to use logarithmic scale for axes. Defaults to False.</p> <code>False</code> <code>s</code> <code>int</code> <p>Marker size. Defaults to 1.</p> <code>1</code> <code>annotate_genes</code> <code>list or None</code> <p>List of genes to annotate on the plot. Defaults to None.</p> <code>None</code> <code>legend_loc</code> <code>str</code> <p>Location of the legend. Defaults to 'best'.</p> <code>'best'</code> <code>dpi</code> <code>int</code> <p>Dots per inch for the figure resolution. Defaults to 360.</p> <code>360</code> <code>anno_fontsize</code> <code>int</code> <p>Font size for gene annotations. Defaults to 10.</p> <code>10</code>"},{"location":"API%20Reference/plot/plot_function/#stpipe.plot.violin","title":"<code>violin(adata, groupby=None, feature='n_genes', n_rows=1, fig_size=(8, 6), save_path=None, dpi=360)</code>","text":"<p>Generate violin plots to visualize the distribution of a feature across groups.</p> <p>This function generates violin plots to visualize the distribution of a specified feature across different groups in the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An AnnData object containing the data.</p> required <code>groupby</code> <code>str or None</code> <p>Key in adata.obs to group the data. If None, a single violin plot for the entire                     dataset will be generated. Defaults to None.</p> <code>None</code> <code>feature</code> <code>str</code> <p>Feature to visualize. Defaults to 'n_genes'.</p> <code>'n_genes'</code> <code>n_rows</code> <code>int</code> <p>Number of rows in the plot grid. Defaults to 1.</p> <code>1</code> <code>fig_size</code> <code>tuple</code> <p>Size of the figure in inches (width, height). Defaults to (8, 6).</p> <code>(8, 6)</code> <code>save_path</code> <code>str or None</code> <p>File path to save the plot. If None, the plot is not saved. Defaults to None.</p> <code>None</code> <code>dpi</code> <code>int</code> <p>Dots per inch for the figure resolution. Defaults to 360.</p> <code>360</code>"},{"location":"Installation/","title":"Installation","text":""},{"location":"Installation/#installation","title":"Installation","text":"<p>To install STpipe, simply use pip:</p> <pre><code>pip install STpipe-sc\n</code></pre> <p>Once installed, you can verify the installation by importing STpipe  in a Jupyter Notebook or JupyterLab session:</p> <pre><code>import stpipe as sp\n</code></pre>"},{"location":"License/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 mgy520</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"Tutorial/Analyzing%20Zebrafish%2010hpf%20Embryo%20Stereo-seq%20Data%20with%20STpipe/","title":"Analyzing Zebrafish 10hpf Embryo Stereo seq Data with STpipe","text":"<p>Compiled: April 5, 2024</p> <p>For this tutorial, we will be analyzing the a dataset of zebrafish 10hpf embryos freely available from stomics. There are 19102 single cells that were sequenced on the DNBSEQ-T1. The Stereo-seq data is from https://db.cngb.org/stomics/datasets/STDS0000057. Click on the \"Data\" tab, where you can find Stereo-seq and scrna-seq data for zebrafish 10hpf embryos. Both datasets have been analyzed, but we can demonstrate using the raw counts for further analysis.</p> In\u00a0[2]: Copied! <pre>import anndata\nimport stpipe as sp\nimport numpy as np\nimport os\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nfrom collections import OrderedDict\n</pre> import anndata import stpipe as sp import numpy as np import os import warnings warnings.filterwarnings(\"ignore\") from collections import OrderedDict In\u00a0[4]: Copied! <pre>adata=anndata.read_h5ad('zf10_stereoseq.h5ad')\n</pre> adata=anndata.read_h5ad('zf10_stereoseq.h5ad') In\u00a0[5]: Copied! <pre>adata\n</pre> adata Out[5]: <pre>AnnData object with n_obs \u00d7 n_vars = 19102 \u00d7 18698\n    obs: 'orig.ident', 'nCount_RNA', 'nFeature_RNA', 'seurat_clusters', 'spatial_x', 'spatial_y', 'slice', 'time_point', 'bin_annotation', 'colors', 'layer_annotation', 'layer_colors'\n    layers: 'counts'</pre> In\u00a0[6]: Copied! <pre>adata.X=adata.layers['counts']\n</pre> adata.X=adata.layers['counts'] In\u00a0[7]: Copied! <pre>adata.obs['slice'].unique()\n</pre> adata.obs['slice'].unique() Out[7]: <pre>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23, 24, 25, 26])</pre> <p>You can use SpatialQC(https://github.com/mgy520/SpatialQC) to generate a quality control report. Let's continue.</p> In\u00a0[8]: Copied! <pre>adata=sp.filter_cells(adata,min_genes=1)\nadata=sp.filter_genes(adata,min_cells=1)\n</pre> adata=sp.filter_cells(adata,min_genes=1) adata=sp.filter_genes(adata,min_cells=1) In\u00a0[9]: Copied! <pre>sp.violin(adata,feature='n_genes',fig_size=(3,3))\n</pre> sp.violin(adata,feature='n_genes',fig_size=(3,3)) <p>STpipe utilizes the global-scaling normalization method called \"LogNormalize\". This method normalizes the measured expression values of each feature in each cell by the total expression across all features, multiplying by a scaling factor (default is 10000), and then applying a logarithmic transformation to the result.</p> <p>For scaling factor, you can refer to the maximum number of counts and try to avoid a gap of several orders of magnitude. This will affect subsequent differential expression gene analysis.</p> In\u00a0[10]: Copied! <pre>np.max(np.sum(adata.X, axis=1))\n</pre> np.max(np.sum(adata.X, axis=1)) Out[10]: <pre>1983.0</pre> In\u00a0[11]: Copied! <pre>adata=sp.lognormal(adata,scale_factor=2000)\n</pre> adata=sp.lognormal(adata,scale_factor=2000) <p>STpipe uses the VST (Variance Stabilizing Transformation) algorithm to identify highly variable genes, similar to the Seurat in R.</p> In\u00a0[12]: Copied! <pre>adata=sp.vst_highly_variable_genes(adata,n_top_genes=2000)\n</pre> adata=sp.vst_highly_variable_genes(adata,n_top_genes=2000) In\u00a0[13]: Copied! <pre>adata\n</pre> adata Out[13]: <pre>AnnData object with n_obs \u00d7 n_vars = 19102 \u00d7 18698\n    obs: 'orig.ident', 'nCount_RNA', 'nFeature_RNA', 'seurat_clusters', 'spatial_x', 'spatial_y', 'slice', 'time_point', 'bin_annotation', 'colors', 'layer_annotation', 'layer_colors', 'n_genes'\n    var: 'n_cells', 'highly_variable', 'variances_norm', 'means'\n    layers: 'counts'</pre> In\u00a0[14]: Copied! <pre>ranked_genes = np.argsort(adata.var['variances_norm'])[::-1]\ntop_genes = adata.var_names[ranked_genes[:10]]\nsp.variable_plot(adata, log=False,figsize=(4,4),annotate_genes=top_genes)\n</pre> ranked_genes = np.argsort(adata.var['variances_norm'])[::-1] top_genes = adata.var_names[ranked_genes[:10]] sp.variable_plot(adata, log=False,figsize=(4,4),annotate_genes=top_genes) <p>Next, we extract highly variable genes and then standardize the expression matrix to conform to a standard normal distribution with a mean of 0 and a variance of 1. This must be done before conducting PCA analysis.</p> In\u00a0[16]: Copied! <pre>adata.raw = adata\nadata = adata[:, adata.var.highly_variable]\nadata=sp.scale(adata)\n</pre> adata.raw = adata adata = adata[:, adata.var.highly_variable] adata=sp.scale(adata) <p>Next we perform PCA on the scaled data.</p> In\u00a0[17]: Copied! <pre>adata=sp.PCA(adata)\n</pre> adata=sp.PCA(adata) <pre>[pca] &gt;A Python Package for Principal Component Analysis (https://github.com/erdogant/pca)\n[pca] &gt;Input data is a sparse matrix. Method is set to: [trunc_svd].\n[pca] &gt;The PCA reduction is performed on the [2000] columns of the input dataframe.\n[pca] &gt;Fit using Truncated SVD.\n[pca] &gt;Compute loadings and PCs.\n[pca] &gt;Compute explained variance.\n[pca] &gt;done.\n</pre> <p>The PCA variance selection Scree plot is a commonly used visualization tool to aid in determining how many principal components should be retained. This plot illustrates the proportion of variance explained by each principal component, typically showing a gradual decrease in variance explained proportion as the number of principal components increases. In the plot, a \"bend point\" or \"knee\" is often observed, indicating a sharp decline in the proportion of variance explained. This \"knee point\" is typically considered the appropriate position to select the number of principal components because it represents a significant change in the rate of decrease in explained variance proportion with the addition of more principal components. In the figure below, we select the first 15 PCs.</p> In\u00a0[18]: Copied! <pre>sp.pca_variance_ratio(adata,npc=50)\n</pre> sp.pca_variance_ratio(adata,npc=50) <p>After PCA, t-SNE can be employed as a dimensionality reduction technique for further visualization and analysis. t-SNE is particularly useful for visualizing high-dimensional data in lower-dimensional space while preserving the local structure of the data points.</p> In\u00a0[19]: Copied! <pre>adata = sp.tsne(adata, input=15,n_jobs=10)\n</pre> adata = sp.tsne(adata, input=15,n_jobs=10) <pre>[scatterd] &gt;INFO&gt; Precomputed initialization provided. Ignoring initalization-related parameters.\n[scatterd] &gt;INFO&gt; Automatically determined negative gradient method `fft`\n[scatterd] &gt;INFO&gt; Automatically determined negative gradient method `fft`\n</pre> <p>First, we construct a neighbor graph in the PCA space using the NearestNeighbors method to calculate the neighbors for each data point. The results are stored in adata.uns['neighbors'].</p> <p>Next, we can directly utilize the Leiden clustering algorithm. The resolution parameter controls the granularity of the clustering, with higher values leading to more clusters.</p> In\u00a0[20]: Copied! <pre>adata=sp.find_neighbors(adata,n_components=15,n_neighbors=30)\n</pre> adata=sp.find_neighbors(adata,n_components=15,n_neighbors=30) In\u00a0[24]: Copied! <pre>adata = sp.leiden(adata,resolution=0.5)\n</pre> adata = sp.leiden(adata,resolution=0.5) In\u00a0[25]: Copied! <pre>adata.obs['leiden'].value_counts()\n</pre> adata.obs['leiden'].value_counts() Out[25]: <pre>3    6928\n2    4242\n1    3991\n0    3246\n4     695\nName: leiden, dtype: int64</pre> <p>Plot the Leiden clustering on the t-SNE results.</p> In\u00a0[36]: Copied! <pre>sp.plot_tsne(adata,by='leiden',cmap='tab10',s=3)\n</pre> sp.plot_tsne(adata,by='leiden',cmap='tab10',s=3) <p>In the differential gene expression analysis step, log-normalized data for all genes is utilized.</p> In\u00a0[28]: Copied! <pre>adata = adata.raw.to_adata()\n</pre> adata = adata.raw.to_adata() <p>STpipe employs Welch's t-test and can utilize the findallmarkers function to identify marker genes for all clusters by comparing the current cluster with all other clusters. You can also use the find_markers_between_groups function to identify differentially expressed genes between two clusters.</p> In\u00a0[29]: Copied! <pre>adata=sp.findallmarkers(adata,cluster_key='leiden',min_pct=0.1)\n</pre> adata=sp.findallmarkers(adata,cluster_key='leiden',min_pct=0.1) In\u00a0[46]: Copied! <pre>top_genes = {}\nfor cluster, df in adata.uns['markers_all'].items():\n    top_genes_list = df.sort_values(by='pval', ascending=True)['gene'].head(10).tolist()\n    top_genes[str(cluster)] = top_genes_list\n\nall_top_genes = [gene for genes in top_genes.values() for gene in genes]\n</pre> top_genes = {} for cluster, df in adata.uns['markers_all'].items():     top_genes_list = df.sort_values(by='pval', ascending=True)['gene'].head(10).tolist()     top_genes[str(cluster)] = top_genes_list  all_top_genes = [gene for genes in top_genes.values() for gene in genes] In\u00a0[32]: Copied! <pre>adata.layers['logcounts']=adata.X\n</pre> adata.layers['logcounts']=adata.X In\u00a0[33]: Copied! <pre>adata=sp.scale(adata)\n</pre> adata=sp.scale(adata) In\u00a0[48]: Copied! <pre>sp.plot_marker_dotplot(adata,groupby='leiden',genes=all_top_genes,figsize=(5,8))\n</pre> sp.plot_marker_dotplot(adata,groupby='leiden',genes=all_top_genes,figsize=(5,8))"},{"location":"Tutorial/Analyzing%20Zebrafish%2010hpf%20Embryo%20Stereo-seq%20Data%20with%20STpipe/#analyzing-zebrafish-10hpf-embryo-stereo-seq-data-with-stpipe","title":"Analyzing Zebrafish 10hpf Embryo Stereo-seq Data with STpipe\u00b6","text":""},{"location":"Tutorial/Analyzing%20Zebrafish%2010hpf%20Embryo%20Stereo-seq%20Data%20with%20STpipe/#import-the-required-packages","title":"Import the required packages\u00b6","text":""},{"location":"Tutorial/Analyzing%20Zebrafish%2010hpf%20Embryo%20Stereo-seq%20Data%20with%20STpipe/#import-the-zebrafish-stereo-seq-data","title":"Import the zebrafish Stereo-seq data\u00b6","text":""},{"location":"Tutorial/Analyzing%20Zebrafish%2010hpf%20Embryo%20Stereo-seq%20Data%20with%20STpipe/#filter","title":"Filter\u00b6","text":""},{"location":"Tutorial/Analyzing%20Zebrafish%2010hpf%20Embryo%20Stereo-seq%20Data%20with%20STpipe/#normalize","title":"Normalize\u00b6","text":""},{"location":"Tutorial/Analyzing%20Zebrafish%2010hpf%20Embryo%20Stereo-seq%20Data%20with%20STpipe/#find-variable-genes","title":"Find variable genes\u00b6","text":""},{"location":"Tutorial/Analyzing%20Zebrafish%2010hpf%20Embryo%20Stereo-seq%20Data%20with%20STpipe/#scale","title":"Scale\u00b6","text":""},{"location":"Tutorial/Analyzing%20Zebrafish%2010hpf%20Embryo%20Stereo-seq%20Data%20with%20STpipe/#pca","title":"PCA\u00b6","text":""},{"location":"Tutorial/Analyzing%20Zebrafish%2010hpf%20Embryo%20Stereo-seq%20Data%20with%20STpipe/#determine-the-pcs-used-for-subsequent-analysis","title":"Determine the PCs used for subsequent analysis.\u00b6","text":""},{"location":"Tutorial/Analyzing%20Zebrafish%2010hpf%20Embryo%20Stereo-seq%20Data%20with%20STpipe/#tsne","title":"TSNE\u00b6","text":""},{"location":"Tutorial/Analyzing%20Zebrafish%2010hpf%20Embryo%20Stereo-seq%20Data%20with%20STpipe/#cluster","title":"Cluster\u00b6","text":""},{"location":"Tutorial/Analyzing%20Zebrafish%2010hpf%20Embryo%20Stereo-seq%20Data%20with%20STpipe/#find-markers","title":"Find markers\u00b6","text":""},{"location":"Tutorial/Identify%20false%20positive%20genes%20with%20STpipe/","title":"Identify false positive genes with STpipe","text":"<p>Compiled: April 5, 2024</p> <p>For this tutorial, we will be analyzing the a dataset of zebrafish 10hpf embryos freely available from stomics. There are 19102 single cells that were sequenced on the DNBSEQ-T1. The Stereo-seq data is from https://db.cngb.org/stomics/datasets/STDS0000057. Click on the \"Data\" tab, where you can find Stereo-seq and scrna-seq data for zebrafish 10hpf embryos. Both datasets have been analyzed, but we can demonstrate using the raw counts for further analysis.</p> In\u00a0[62]: Copied! <pre>import anndata\nimport stpipe as sp\nimport numpy as np\nimport pandas as pd\nimport os\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nfrom collections import OrderedDict\n</pre> import anndata import stpipe as sp import numpy as np import pandas as pd import os import warnings warnings.filterwarnings(\"ignore\") from collections import OrderedDict In\u00a0[45]: Copied! <pre>adata=anndata.read_h5ad('zf10_stereoseq.h5ad')\n</pre> adata=anndata.read_h5ad('zf10_stereoseq.h5ad') In\u00a0[46]: Copied! <pre>adata\n</pre> adata Out[46]: <pre>AnnData object with n_obs \u00d7 n_vars = 19102 \u00d7 18698\n    obs: 'orig.ident', 'nCount_RNA', 'nFeature_RNA', 'seurat_clusters', 'spatial_x', 'spatial_y', 'slice', 'time_point', 'bin_annotation', 'colors', 'layer_annotation', 'layer_colors'\n    layers: 'counts'</pre> In\u00a0[47]: Copied! <pre>adata.X=adata.layers['counts']\n</pre> adata.X=adata.layers['counts'] In\u00a0[48]: Copied! <pre>adata.obs['slice'].unique()\n</pre> adata.obs['slice'].unique() Out[48]: <pre>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23, 24, 25, 26])</pre> <p>bdata is already lognormal</p> In\u00a0[49]: Copied! <pre>bdata=anndata.read_h5ad('f10_scRNA.h5ad')\n</pre> bdata=anndata.read_h5ad('f10_scRNA.h5ad') <p>STpipe utilizes the global-scaling normalization method called \"LogNormalize\". This method normalizes the measured expression values of each feature in each cell by the total expression across all features, multiplying by a scaling factor (default is 10000), and then applying a logarithmic transformation to the result.</p> <p>For scaling factor, you can refer to the maximum number of counts and try to avoid a gap of several orders of magnitude. This will affect subsequent differential expression gene analysis.</p> In\u00a0[50]: Copied! <pre>np.max(np.sum(adata.X, axis=1))\n</pre> np.max(np.sum(adata.X, axis=1)) Out[50]: <pre>1983.0</pre> In\u00a0[51]: Copied! <pre>adata=sp.lognormal(adata,scale_factor=2000)\n</pre> adata=sp.lognormal(adata,scale_factor=2000) <p>Next, we proceed to identify false positive genes. Due to misalignment of adata slices in 3D, we choose slice 10 as an example.</p> In\u00a0[52]: Copied! <pre>adata = adata[adata.obs['slice']==10]\n</pre> adata = adata[adata.obs['slice']==10] In\u00a0[54]: Copied! <pre>adata = sp.filter_genes(adata,min_cells=1)\n</pre> adata = sp.filter_genes(adata,min_cells=1) In\u00a0[55]: Copied! <pre>adata.obsm['spatial']=adata.obs[['spatial_x','spatial_y']].values\n</pre> adata.obsm['spatial']=adata.obs[['spatial_x','spatial_y']].values In\u00a0[36]: Copied! <pre>markers = pd.read_csv('zf10_cellmarkers.txt')\n</pre> markers = pd.read_csv('zf10_cellmarkers.txt') In\u00a0[56]: Copied! <pre>m_sp,m_sc,ad_ge,sp=sp.falsepositive(adata,bdata,train_gene=markers.gene)\n</pre> m_sp,m_sc,ad_ge,sp=sp.falsepositive(adata,bdata,train_gene=markers.gene) <pre>[scatterd] &gt;INFO&gt; 309 training genes are saved in `uns``training_genes` of both single cell and spatial Anndatas.\n[scatterd] &gt;INFO&gt; 11963 overlapped genes are saved in `uns``overlap_genes` of both single cell and spatial Anndatas.\n[scatterd] &gt;INFO&gt; uniform based density prior is calculated and saved in `obs``uniform_density` of the spatial Anndata.\n[scatterd] &gt;INFO&gt; rna count based density prior is calculated and saved in `obs``rna_count_based_density` of the spatial Anndata.\n[scatterd] &gt;INFO&gt; Allocate tensors for mapping.\n[scatterd] &gt;INFO&gt; Begin training with 309 genes and rna_count_based density_prior in cells mode...\n[scatterd] &gt;INFO&gt; Saving results..\n</pre> In\u00a0[67]: Copied! <pre>m_sc_filtered = m_sc[m_sc &lt; 0.05].index.tolist()\nm_sp_filtered = m_sp[m_sp &gt; 0.2].index.tolist()\nintersecting_genes = set(m_sc_filtered).intersection(set(m_sp_filtered))\nprint(len(intersecting_genes))\n</pre> m_sc_filtered = m_sc[m_sc &lt; 0.05].index.tolist() m_sp_filtered = m_sp[m_sp &gt; 0.2].index.tolist() intersecting_genes = set(m_sc_filtered).intersection(set(m_sp_filtered)) print(len(intersecting_genes)) <pre>9\n</pre> <p>We select genes with high Moran I values in spatial transcriptomics but low in scRNA-seq data. Users should inspect these genes to consider their removal to avoid bias in subsequent cell type annotations.</p> In\u00a0[68]: Copied! <pre>sp.plot_moran(m_sc,m_sp,anno=intersecting_genes,figsize=(8,8))\n</pre> sp.plot_moran(m_sc,m_sp,anno=intersecting_genes,figsize=(8,8))"},{"location":"Tutorial/Identify%20false%20positive%20genes%20with%20STpipe/#use-stpipe-to-identify-false-positive-genes","title":"Use STpipe to identify false positive genes\u00b6","text":""},{"location":"Tutorial/Identify%20false%20positive%20genes%20with%20STpipe/#import-the-required-packages","title":"Import the required packages\u00b6","text":""},{"location":"Tutorial/Identify%20false%20positive%20genes%20with%20STpipe/#import-the-zebrafish-stereo-seq-and-scrna-seq-data","title":"Import the zebrafish Stereo-seq and scRNA-seq data\u00b6","text":""},{"location":"Tutorial/Identify%20false%20positive%20genes%20with%20STpipe/#normalize","title":"Normalize\u00b6","text":""},{"location":"Tutorial/Identify%20false%20positive%20genes%20with%20STpipe/#identify-false-positive-genes","title":"Identify false positive genes\u00b6","text":""},{"location":"Tutorial/Spatail%20cluster%20with%20STpipe/","title":"Spatail cluster with STpipe","text":"<p>Compiled: April 5, 2024</p> <p>For this tutorial, we will be analyzing the a dataset of zebrafish 10hpf embryos freely available from stomics. There are 19102 single cells that were sequenced on the DNBSEQ-T1. The Stereo-seq data is from https://db.cngb.org/stomics/datasets/STDS0000057. Click on the \"Data\" tab, where you can find Stereo-seq and scrna-seq data for zebrafish 10hpf embryos. Both datasets have been analyzed, but we can demonstrate using the raw counts for further analysis.</p> In\u00a0[2]: Copied! <pre>import anndata\nimport stpipe as sp\nimport numpy as np\nimport os\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nfrom collections import OrderedDict\n</pre> import anndata import stpipe as sp import numpy as np import os import warnings warnings.filterwarnings(\"ignore\") from collections import OrderedDict In\u00a0[3]: Copied! <pre>adata=anndata.read_h5ad('zf10_stereoseq.h5ad')\n</pre> adata=anndata.read_h5ad('zf10_stereoseq.h5ad') In\u00a0[4]: Copied! <pre>adata\n</pre> adata Out[4]: <pre>AnnData object with n_obs \u00d7 n_vars = 19102 \u00d7 18698\n    obs: 'orig.ident', 'nCount_RNA', 'nFeature_RNA', 'seurat_clusters', 'spatial_x', 'spatial_y', 'slice', 'time_point', 'bin_annotation', 'colors', 'layer_annotation', 'layer_colors'\n    layers: 'counts'</pre> In\u00a0[5]: Copied! <pre>adata.X=adata.layers['counts']\n</pre> adata.X=adata.layers['counts'] In\u00a0[6]: Copied! <pre>adata.obs['slice'].unique()\n</pre> adata.obs['slice'].unique() Out[6]: <pre>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23, 24, 25, 26])</pre> <p>You can use SpatialQC(https://github.com/mgy520/SpatialQC) to generate a quality control report. Let's continue.</p> In\u00a0[7]: Copied! <pre>adata=sp.filter_cells(adata,min_genes=1)\nadata=sp.filter_genes(adata,min_cells=1)\n</pre> adata=sp.filter_cells(adata,min_genes=1) adata=sp.filter_genes(adata,min_cells=1) In\u00a0[8]: Copied! <pre>sp.violin(adata,feature='n_genes',fig_size=(3,3))\n</pre> sp.violin(adata,feature='n_genes',fig_size=(3,3)) <p>STpipe utilizes the global-scaling normalization method called \"LogNormalize\". This method normalizes the measured expression values of each feature in each cell by the total expression across all features, multiplying by a scaling factor (default is 10000), and then applying a logarithmic transformation to the result.</p> <p>For scaling factor, you can refer to the maximum number of counts and try to avoid a gap of several orders of magnitude. This will affect subsequent differential expression gene analysis.</p> In\u00a0[9]: Copied! <pre>np.max(np.sum(adata.X, axis=1))\n</pre> np.max(np.sum(adata.X, axis=1)) Out[9]: <pre>1983.0</pre> In\u00a0[10]: Copied! <pre>adata=sp.lognormal(adata,scale_factor=2000)\n</pre> adata=sp.lognormal(adata,scale_factor=2000) <p>STpipe uses the VST (Variance Stabilizing Transformation) algorithm to identify highly variable genes, similar to the Seurat in R.</p> In\u00a0[11]: Copied! <pre>adata=sp.vst_highly_variable_genes(adata,n_top_genes=2000)\n</pre> adata=sp.vst_highly_variable_genes(adata,n_top_genes=2000) In\u00a0[12]: Copied! <pre>adata\n</pre> adata Out[12]: <pre>AnnData object with n_obs \u00d7 n_vars = 19102 \u00d7 18698\n    obs: 'orig.ident', 'nCount_RNA', 'nFeature_RNA', 'seurat_clusters', 'spatial_x', 'spatial_y', 'slice', 'time_point', 'bin_annotation', 'colors', 'layer_annotation', 'layer_colors', 'n_genes'\n    var: 'n_cells', 'highly_variable', 'variances_norm', 'means'\n    layers: 'counts'</pre> In\u00a0[13]: Copied! <pre>ranked_genes = np.argsort(adata.var['variances_norm'])[::-1]\ntop_genes = adata.var_names[ranked_genes[:10]]\nsp.variable_plot(adata, log=False,figsize=(4,4),annotate_genes=top_genes)\n</pre> ranked_genes = np.argsort(adata.var['variances_norm'])[::-1] top_genes = adata.var_names[ranked_genes[:10]] sp.variable_plot(adata, log=False,figsize=(4,4),annotate_genes=top_genes) <p>Next, we extract highly variable genes and then standardize the expression matrix to conform to a standard normal distribution with a mean of 0 and a variance of 1. This must be done before conducting PCA analysis.</p> In\u00a0[14]: Copied! <pre>adata.layers['logcounts'] = adata.X\nadata.raw = adata\nadata = adata[:, adata.var.highly_variable]\nadata=sp.scale(adata)\n</pre> adata.layers['logcounts'] = adata.X adata.raw = adata adata = adata[:, adata.var.highly_variable] adata=sp.scale(adata) <p>Next we perform PCA on the scaled data.</p> In\u00a0[15]: Copied! <pre>adata=sp.PCA(adata)\n</pre> adata=sp.PCA(adata) <pre>[pca] &gt;A Python Package for Principal Component Analysis (https://github.com/erdogant/pca)\n[pca] &gt;Input data is a sparse matrix. Method is set to: [trunc_svd].\n[pca] &gt;The PCA reduction is performed on the [2000] columns of the input dataframe.\n[pca] &gt;Fit using Truncated SVD.\n[pca] &gt;Compute loadings and PCs.\n[pca] &gt;Compute explained variance.\n[pca] &gt;done.\n</pre> <p>The PCA variance selection Scree plot is a commonly used visualization tool to aid in determining how many principal components should be retained. This plot illustrates the proportion of variance explained by each principal component, typically showing a gradual decrease in variance explained proportion as the number of principal components increases. In the plot, a \"bend point\" or \"knee\" is often observed, indicating a sharp decline in the proportion of variance explained. This \"knee point\" is typically considered the appropriate position to select the number of principal components because it represents a significant change in the rate of decrease in explained variance proportion with the addition of more principal components. In the figure below, we select the first 15 PCs.</p> In\u00a0[16]: Copied! <pre>sp.pca_variance_ratio(adata,npc=50)\n</pre> sp.pca_variance_ratio(adata,npc=50) <p>STpipe utilizes SC-MEB for spatial clustering. SC-MEB constructs a two-layer hierarchical probabilistic model. The first layer defines the conditional probability of low-dimensional representations of gene expression (e.g., principal components), while the second layer describes the prior probability of hidden labels and implements an MRF prior to promote spatial smoothness. SC-MEB is capable of automatically selecting the number of clusters. For more details, refer to here .</p> <p>Here, we use the example of the Slice 10.</p> In\u00a0[17]: Copied! <pre>adata_s10 = adata[adata.obs['slice']==10]\n</pre> adata_s10 = adata[adata.obs['slice']==10] In\u00a0[18]: Copied! <pre>adata_s10.obsm['spatial']=adata_s10.obs[['spatial_x','spatial_y']].values\n</pre> adata_s10.obsm['spatial']=adata_s10.obs[['spatial_x','spatial_y']].values In\u00a0[25]: Copied! <pre>adata_s10=adata_s10.raw.to_adata()\n</pre> adata_s10=adata_s10.raw.to_adata() In\u00a0[27]: Copied! <pre>adata_s10 = adata_s10[:, adata_s10.var.highly_variable]\n</pre> adata_s10 = adata_s10[:, adata_s10.var.highly_variable] In\u00a0[34]: Copied! <pre>adata_s10.obs['row']=adata_s10.obs['spatial_x']\nadata_s10.obs['col']=adata_s10.obs['spatial_y']\n</pre> adata_s10.obs['row']=adata_s10.obs['spatial_x'] adata_s10.obs['col']=adata_s10.obs['spatial_y'] In\u00a0[36]: Copied! <pre>adata_s10=sp.cluster(adata_s10,K_set=np.arange(6,12),n_PCs=15,neighborhood_size=50)\n</pre> adata_s10=sp.cluster(adata_s10,K_set=np.arange(6,12),n_PCs=15,neighborhood_size=50) <pre>Starting parallel computing...diff Energy = 28.1336\ndiff Energy = 8.30834\ndiff Energy = 8.7\ndiff Energy = 4.5\ndiff Energy = 19.6685\ndiff Energy = 5.59957\ndiff Energy = 3.82729\ndiff Energy = 2.8\ndiff Energy = 5.31734\ndiff Energy = 7.6\ndiff Energy = 32.9528\ndiff Energy = 5.2\ndiff Energy = 2.23038\ndiff Energy = 8.28174\ndiff Energy = 7.90139\ndiff Energy = 1.5\ndiff Energy = 5.37488\ndiff Energy = 12.7513\nICM Converged at Iteration = 7\nICM Converged at Iteration = 4\nICM Converged at Iteration = 2\nICM Converged at Iteration = 3\ndiff Energy = 2.4\nICM Converged at Iteration = 2\ndiff Energy = 2.87103\ndiff Energy = 11.9392\ndiff Energy = 2.43979\nICM Converged at Iteration = 8\ndiff Energy = 11.1484\ndiff Energy = 25.3783\nICM Converged at Iteration = 3\ndiff Energy = 8\ndiff Energy = 6\ndiff Energy = 4.8\nICM Converged at Iteration = 2\n</pre> In\u00a0[41]: Copied! <pre>sp.plot_spatial(adata_s10,by='cluster',categorical=True,cmap='tab10',legend=True)\n</pre> sp.plot_spatial(adata_s10,by='cluster',categorical=True,cmap='tab10',legend=True)"},{"location":"Tutorial/Spatail%20cluster%20with%20STpipe/#spatial-clustering-of-zebrafish-10hpf-embryo-stereo-seq-data-using-stpipe","title":"Spatial clustering of zebrafish 10hpf embryo stereo-seq data using STpipe\u00b6","text":""},{"location":"Tutorial/Spatail%20cluster%20with%20STpipe/#import-the-required-packages","title":"Import the required packages\u00b6","text":""},{"location":"Tutorial/Spatail%20cluster%20with%20STpipe/#import-the-zebrafish-stereo-seq-data","title":"Import the zebrafish Stereo-seq data\u00b6","text":""},{"location":"Tutorial/Spatail%20cluster%20with%20STpipe/#filter","title":"Filter\u00b6","text":""},{"location":"Tutorial/Spatail%20cluster%20with%20STpipe/#normalize","title":"Normalize\u00b6","text":""},{"location":"Tutorial/Spatail%20cluster%20with%20STpipe/#find-variable-genes","title":"Find variable genes\u00b6","text":""},{"location":"Tutorial/Spatail%20cluster%20with%20STpipe/#scale","title":"Scale\u00b6","text":""},{"location":"Tutorial/Spatail%20cluster%20with%20STpipe/#pca","title":"PCA\u00b6","text":""},{"location":"Tutorial/Spatail%20cluster%20with%20STpipe/#determine-the-pcs-used-for-subsequent-analysis","title":"Determine the PCs used for subsequent analysis.\u00b6","text":""},{"location":"Tutorial/Spatail%20cluster%20with%20STpipe/#spatial-cluster","title":"Spatial cluster\u00b6","text":""},{"location":"Tutorial/Spatial%20cluster%20with%20STpipe/","title":"Spatial cluster with STpipe","text":"<p>Compiled: April 5, 2024</p> <p>For this tutorial, we will be analyzing the a dataset of zebrafish 10hpf embryos freely available from stomics. There are 19102 single cells that were sequenced on the DNBSEQ-T1. The Stereo-seq data is from https://db.cngb.org/stomics/datasets/STDS0000057. Click on the \"Data\" tab, where you can find Stereo-seq and scrna-seq data for zebrafish 10hpf embryos. Both datasets have been analyzed, but we can demonstrate using the raw counts for further analysis.</p> In\u00a0[2]: Copied! <pre>import anndata\nimport stpipe as sp\nimport numpy as np\nimport os\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nfrom collections import OrderedDict\n</pre> import anndata import stpipe as sp import numpy as np import os import warnings warnings.filterwarnings(\"ignore\") from collections import OrderedDict In\u00a0[3]: Copied! <pre>adata=anndata.read_h5ad('zf10_stereoseq.h5ad')\n</pre> adata=anndata.read_h5ad('zf10_stereoseq.h5ad') In\u00a0[4]: Copied! <pre>adata\n</pre> adata Out[4]: <pre>AnnData object with n_obs \u00d7 n_vars = 19102 \u00d7 18698\n    obs: 'orig.ident', 'nCount_RNA', 'nFeature_RNA', 'seurat_clusters', 'spatial_x', 'spatial_y', 'slice', 'time_point', 'bin_annotation', 'colors', 'layer_annotation', 'layer_colors'\n    layers: 'counts'</pre> In\u00a0[5]: Copied! <pre>adata.X=adata.layers['counts']\n</pre> adata.X=adata.layers['counts'] In\u00a0[6]: Copied! <pre>adata.obs['slice'].unique()\n</pre> adata.obs['slice'].unique() Out[6]: <pre>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23, 24, 25, 26])</pre> <p>You can use SpatialQC(https://github.com/mgy520/SpatialQC) to generate a quality control report. Let's continue.</p> In\u00a0[7]: Copied! <pre>adata=sp.filter_cells(adata,min_genes=1)\nadata=sp.filter_genes(adata,min_cells=1)\n</pre> adata=sp.filter_cells(adata,min_genes=1) adata=sp.filter_genes(adata,min_cells=1) In\u00a0[8]: Copied! <pre>sp.violin(adata,feature='n_genes',fig_size=(3,3))\n</pre> sp.violin(adata,feature='n_genes',fig_size=(3,3)) <p>STpipe utilizes the global-scaling normalization method called \"LogNormalize\". This method normalizes the measured expression values of each feature in each cell by the total expression across all features, multiplying by a scaling factor (default is 10000), and then applying a logarithmic transformation to the result.</p> <p>For scaling factor, you can refer to the maximum number of counts and try to avoid a gap of several orders of magnitude. This will affect subsequent differential expression gene analysis.</p> In\u00a0[9]: Copied! <pre>np.max(np.sum(adata.X, axis=1))\n</pre> np.max(np.sum(adata.X, axis=1)) Out[9]: <pre>1983.0</pre> In\u00a0[10]: Copied! <pre>adata=sp.lognormal(adata,scale_factor=2000)\n</pre> adata=sp.lognormal(adata,scale_factor=2000) <p>STpipe uses the VST (Variance Stabilizing Transformation) algorithm to identify highly variable genes, similar to the Seurat in R.</p> In\u00a0[11]: Copied! <pre>adata=sp.vst_highly_variable_genes(adata,n_top_genes=2000)\n</pre> adata=sp.vst_highly_variable_genes(adata,n_top_genes=2000) In\u00a0[12]: Copied! <pre>adata\n</pre> adata Out[12]: <pre>AnnData object with n_obs \u00d7 n_vars = 19102 \u00d7 18698\n    obs: 'orig.ident', 'nCount_RNA', 'nFeature_RNA', 'seurat_clusters', 'spatial_x', 'spatial_y', 'slice', 'time_point', 'bin_annotation', 'colors', 'layer_annotation', 'layer_colors', 'n_genes'\n    var: 'n_cells', 'highly_variable', 'variances_norm', 'means'\n    layers: 'counts'</pre> In\u00a0[13]: Copied! <pre>ranked_genes = np.argsort(adata.var['variances_norm'])[::-1]\ntop_genes = adata.var_names[ranked_genes[:10]]\nsp.variable_plot(adata, log=False,figsize=(4,4),annotate_genes=top_genes)\n</pre> ranked_genes = np.argsort(adata.var['variances_norm'])[::-1] top_genes = adata.var_names[ranked_genes[:10]] sp.variable_plot(adata, log=False,figsize=(4,4),annotate_genes=top_genes) <p>Next, we extract highly variable genes and then standardize the expression matrix to conform to a standard normal distribution with a mean of 0 and a variance of 1. This must be done before conducting PCA analysis.</p> In\u00a0[14]: Copied! <pre>adata.layers['logcounts'] = adata.X\nadata.raw = adata\nadata = adata[:, adata.var.highly_variable]\nadata=sp.scale(adata)\n</pre> adata.layers['logcounts'] = adata.X adata.raw = adata adata = adata[:, adata.var.highly_variable] adata=sp.scale(adata) <p>Next we perform PCA on the scaled data.</p> In\u00a0[15]: Copied! <pre>adata=sp.PCA(adata)\n</pre> adata=sp.PCA(adata) <pre>[pca] &gt;A Python Package for Principal Component Analysis (https://github.com/erdogant/pca)\n[pca] &gt;Input data is a sparse matrix. Method is set to: [trunc_svd].\n[pca] &gt;The PCA reduction is performed on the [2000] columns of the input dataframe.\n[pca] &gt;Fit using Truncated SVD.\n[pca] &gt;Compute loadings and PCs.\n[pca] &gt;Compute explained variance.\n[pca] &gt;done.\n</pre> <p>The PCA variance selection Scree plot is a commonly used visualization tool to aid in determining how many principal components should be retained. This plot illustrates the proportion of variance explained by each principal component, typically showing a gradual decrease in variance explained proportion as the number of principal components increases. In the plot, a \"bend point\" or \"knee\" is often observed, indicating a sharp decline in the proportion of variance explained. This \"knee point\" is typically considered the appropriate position to select the number of principal components because it represents a significant change in the rate of decrease in explained variance proportion with the addition of more principal components. In the figure below, we select the first 15 PCs.</p> In\u00a0[16]: Copied! <pre>sp.pca_variance_ratio(adata,npc=50)\n</pre> sp.pca_variance_ratio(adata,npc=50) <p>STpipe utilizes SC-MEB for spatial clustering. SC-MEB constructs a two-layer hierarchical probabilistic model. The first layer defines the conditional probability of low-dimensional representations of gene expression (e.g., principal components), while the second layer describes the prior probability of hidden labels and implements an MRF prior to promote spatial smoothness. SC-MEB is capable of automatically selecting the number of clusters. For more details, refer to here .</p> <p>Here, we use the example of the Slice 10.</p> In\u00a0[17]: Copied! <pre>adata_s10 = adata[adata.obs['slice']==10]\n</pre> adata_s10 = adata[adata.obs['slice']==10] In\u00a0[18]: Copied! <pre>adata_s10.obsm['spatial']=adata_s10.obs[['spatial_x','spatial_y']].values\n</pre> adata_s10.obsm['spatial']=adata_s10.obs[['spatial_x','spatial_y']].values In\u00a0[25]: Copied! <pre>adata_s10=adata_s10.raw.to_adata()\n</pre> adata_s10=adata_s10.raw.to_adata() In\u00a0[27]: Copied! <pre>adata_s10 = adata_s10[:, adata_s10.var.highly_variable]\n</pre> adata_s10 = adata_s10[:, adata_s10.var.highly_variable] In\u00a0[34]: Copied! <pre>adata_s10.obs['row']=adata_s10.obs['spatial_x']\nadata_s10.obs['col']=adata_s10.obs['spatial_y']\n</pre> adata_s10.obs['row']=adata_s10.obs['spatial_x'] adata_s10.obs['col']=adata_s10.obs['spatial_y'] In\u00a0[36]: Copied! <pre>adata_s10=sp.cluster(adata_s10,K_set=np.arange(6,12),n_PCs=15,neighborhood_size=50)\n</pre> adata_s10=sp.cluster(adata_s10,K_set=np.arange(6,12),n_PCs=15,neighborhood_size=50) <pre>Starting parallel computing...diff Energy = 28.1336\ndiff Energy = 8.30834\ndiff Energy = 8.7\ndiff Energy = 4.5\ndiff Energy = 19.6685\ndiff Energy = 5.59957\ndiff Energy = 3.82729\ndiff Energy = 2.8\ndiff Energy = 5.31734\ndiff Energy = 7.6\ndiff Energy = 32.9528\ndiff Energy = 5.2\ndiff Energy = 2.23038\ndiff Energy = 8.28174\ndiff Energy = 7.90139\ndiff Energy = 1.5\ndiff Energy = 5.37488\ndiff Energy = 12.7513\nICM Converged at Iteration = 7\nICM Converged at Iteration = 4\nICM Converged at Iteration = 2\nICM Converged at Iteration = 3\ndiff Energy = 2.4\nICM Converged at Iteration = 2\ndiff Energy = 2.87103\ndiff Energy = 11.9392\ndiff Energy = 2.43979\nICM Converged at Iteration = 8\ndiff Energy = 11.1484\ndiff Energy = 25.3783\nICM Converged at Iteration = 3\ndiff Energy = 8\ndiff Energy = 6\ndiff Energy = 4.8\nICM Converged at Iteration = 2\n</pre> In\u00a0[41]: Copied! <pre>sp.plot_spatial(adata_s10,by='cluster',categorical=True,cmap='tab10',legend=True)\n</pre> sp.plot_spatial(adata_s10,by='cluster',categorical=True,cmap='tab10',legend=True)"},{"location":"Tutorial/Spatial%20cluster%20with%20STpipe/#spatial-clustering-of-zebrafish-10hpf-embryo-stereo-seq-data-using-stpipe","title":"Spatial clustering of zebrafish 10hpf embryo stereo-seq data using STpipe\u00b6","text":""},{"location":"Tutorial/Spatial%20cluster%20with%20STpipe/#import-the-required-packages","title":"Import the required packages\u00b6","text":""},{"location":"Tutorial/Spatial%20cluster%20with%20STpipe/#import-the-zebrafish-stereo-seq-data","title":"Import the zebrafish Stereo-seq data\u00b6","text":""},{"location":"Tutorial/Spatial%20cluster%20with%20STpipe/#filter","title":"Filter\u00b6","text":""},{"location":"Tutorial/Spatial%20cluster%20with%20STpipe/#normalize","title":"Normalize\u00b6","text":""},{"location":"Tutorial/Spatial%20cluster%20with%20STpipe/#find-variable-genes","title":"Find variable genes\u00b6","text":""},{"location":"Tutorial/Spatial%20cluster%20with%20STpipe/#scale","title":"Scale\u00b6","text":""},{"location":"Tutorial/Spatial%20cluster%20with%20STpipe/#pca","title":"PCA\u00b6","text":""},{"location":"Tutorial/Spatial%20cluster%20with%20STpipe/#determine-the-pcs-used-for-subsequent-analysis","title":"Determine the PCs used for subsequent analysis.\u00b6","text":""},{"location":"Tutorial/Spatial%20cluster%20with%20STpipe/#spatial-cluster","title":"Spatial cluster\u00b6","text":""},{"location":"Tutorial/Spatial%20metacell%20analysis%20with%20STpipe/","title":"Spatial metacell analysis with STpipe","text":"<p>Compiled: April 5, 2024</p> <p>For this tutorial, we will be analyzing the a dataset of zebrafish 10hpf embryos freely available from stomics.  There are 19102 single cells that were sequenced on the DNBSEQ-T1.  The Stereo-seq data is from https://db.cngb.org/stomics/datasets/STDS0000057.  Click on the \"Data\" tab, where you can find Stereo-seq data for zebrafish 10hpf embryos.</p> In\u00a0[2]: Copied! <pre>import anndata\nimport stpipe as sp\nimport numpy as np\nimport os\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nfrom collections import OrderedDict\n</pre> import anndata import stpipe as sp import numpy as np import os import warnings warnings.filterwarnings(\"ignore\") from collections import OrderedDict In\u00a0[3]: Copied! <pre>adata=anndata.read_h5ad('zf10_stereoseq.h5ad')\n</pre> adata=anndata.read_h5ad('zf10_stereoseq.h5ad') In\u00a0[4]: Copied! <pre>adata\n</pre> adata Out[4]: <pre>AnnData object with n_obs \u00d7 n_vars = 19102 \u00d7 18698\n    obs: 'orig.ident', 'nCount_RNA', 'nFeature_RNA', 'seurat_clusters', 'spatial_x', 'spatial_y', 'slice', 'time_point', 'bin_annotation', 'colors', 'layer_annotation', 'layer_colors'\n    layers: 'counts'</pre> In\u00a0[5]: Copied! <pre>adata.X=adata.layers['counts']\n</pre> adata.X=adata.layers['counts'] In\u00a0[6]: Copied! <pre>adata.obs['slice'].unique()\n</pre> adata.obs['slice'].unique() Out[6]: <pre>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n       18, 19, 20, 21, 22, 23, 24, 25, 26])</pre> <p>You can use SpatialQC(https://github.com/mgy520/SpatialQC) to generate a quality control report. Let's continue.</p> In\u00a0[7]: Copied! <pre>adata=sp.filter_cells(adata,min_genes=1)\nadata=sp.filter_genes(adata,min_cells=1)\n</pre> adata=sp.filter_cells(adata,min_genes=1) adata=sp.filter_genes(adata,min_cells=1) In\u00a0[8]: Copied! <pre>sp.violin(adata,feature='n_genes',fig_size=(3,3))\n</pre> sp.violin(adata,feature='n_genes',fig_size=(3,3)) <p>STpipe utilizes the global-scaling normalization method called \"LogNormalize\". This method normalizes the measured expression values of each feature in each cell by the total expression across all features, multiplying by a scaling factor (default is 10000), and then applying a logarithmic transformation to the result.</p> <p>For scaling factor, you can refer to the maximum number of counts and try to avoid a gap of several orders of magnitude. This will affect subsequent differential expression gene analysis.</p> In\u00a0[9]: Copied! <pre>np.max(np.sum(adata.X, axis=1))\n</pre> np.max(np.sum(adata.X, axis=1)) Out[9]: <pre>1983.0</pre> In\u00a0[10]: Copied! <pre>adata=sp.lognormal(adata,scale_factor=2000)\n</pre> adata=sp.lognormal(adata,scale_factor=2000) <p>STpipe uses the VST (Variance Stabilizing Transformation) algorithm to identify highly variable genes, similar to the Seurat in R.</p> In\u00a0[11]: Copied! <pre>adata=sp.vst_highly_variable_genes(adata,n_top_genes=2000)\n</pre> adata=sp.vst_highly_variable_genes(adata,n_top_genes=2000) In\u00a0[12]: Copied! <pre>adata\n</pre> adata Out[12]: <pre>AnnData object with n_obs \u00d7 n_vars = 19102 \u00d7 18698\n    obs: 'orig.ident', 'nCount_RNA', 'nFeature_RNA', 'seurat_clusters', 'spatial_x', 'spatial_y', 'slice', 'time_point', 'bin_annotation', 'colors', 'layer_annotation', 'layer_colors', 'n_genes'\n    var: 'n_cells', 'highly_variable', 'variances_norm', 'means'\n    layers: 'counts'</pre> In\u00a0[13]: Copied! <pre>ranked_genes = np.argsort(adata.var['variances_norm'])[::-1]\ntop_genes = adata.var_names[ranked_genes[:10]]\nsp.variable_plot(adata, log=False,figsize=(4,4),annotate_genes=top_genes)\n</pre> ranked_genes = np.argsort(adata.var['variances_norm'])[::-1] top_genes = adata.var_names[ranked_genes[:10]] sp.variable_plot(adata, log=False,figsize=(4,4),annotate_genes=top_genes) <p>Next, we extract highly variable genes and then standardize the expression matrix to conform to a standard normal distribution with a mean of 0 and a variance of 1. This must be done before conducting PCA analysis.</p> In\u00a0[14]: Copied! <pre>adata.raw = adata\nadata = adata[:, adata.var.highly_variable]\nadata=sp.scale(adata)\n</pre> adata.raw = adata adata = adata[:, adata.var.highly_variable] adata=sp.scale(adata) <p>Next we perform PCA on the scaled data.</p> In\u00a0[15]: Copied! <pre>adata=sp.PCA(adata)\n</pre> adata=sp.PCA(adata) <pre>[pca] &gt;A Python Package for Principal Component Analysis (https://github.com/erdogant/pca)\n[pca] &gt;Input data is a sparse matrix. Method is set to: [trunc_svd].\n[pca] &gt;The PCA reduction is performed on the [2000] columns of the input dataframe.\n[pca] &gt;Fit using Truncated SVD.\n[pca] &gt;Compute loadings and PCs.\n[pca] &gt;Compute explained variance.\n[pca] &gt;done.\n</pre> <p>The PCA variance selection Scree plot is a commonly used visualization tool to aid in determining how many principal components should be retained. This plot illustrates the proportion of variance explained by each principal component, typically showing a gradual decrease in variance explained proportion as the number of principal components increases. In the plot, a \"bend point\" or \"knee\" is often observed, indicating a sharp decline in the proportion of variance explained. This \"knee point\" is typically considered the appropriate position to select the number of principal components because it represents a significant change in the rate of decrease in explained variance proportion with the addition of more principal components. In the figure below, we select the first 15 PCs.</p> In\u00a0[16]: Copied! <pre>sp.pca_variance_ratio(adata,npc=50)\n</pre> sp.pca_variance_ratio(adata,npc=50) <p>After PCA, t-SNE can be employed as a dimensionality reduction technique for further visualization and analysis. t-SNE is particularly useful for visualizing high-dimensional data in lower-dimensional space while preserving the local structure of the data points.</p> In\u00a0[17]: Copied! <pre>adata = sp.tsne(adata, input=15,n_jobs=10)\n</pre> adata = sp.tsne(adata, input=15,n_jobs=10) <pre>[scatterd] &gt;INFO&gt; Precomputed initialization provided. Ignoring initalization-related parameters.\n[scatterd] &gt;INFO&gt; Automatically determined negative gradient method `fft`\n[scatterd] &gt;INFO&gt; Automatically determined negative gradient method `fft`\n</pre> <p>First, we construct a neighbor graph in the PCA space using the NearestNeighbors method to calculate the neighbors for each data point. The results are stored in adata.uns['neighbors'].</p> <p>Next, we can directly utilize the Leiden clustering algorithm. The resolution parameter controls the granularity of the clustering, with higher values leading to more clusters.</p> In\u00a0[18]: Copied! <pre>adata=sp.find_neighbors(adata,n_components=15,n_neighbors=30)\n</pre> adata=sp.find_neighbors(adata,n_components=15,n_neighbors=30) In\u00a0[22]: Copied! <pre>adata = sp.leiden(adata,resolution=0.8)\n</pre> adata = sp.leiden(adata,resolution=0.8) In\u00a0[23]: Copied! <pre>adata.obs['leiden'].value_counts()\n</pre> adata.obs['leiden'].value_counts() Out[23]: <pre>2    3867\n3    3563\n5    2878\n4    2286\n6    2159\n1    1960\n0    1644\n7     745\nName: leiden, dtype: int64</pre> <p>Plot the Leiden clustering on the t-SNE results.</p> In\u00a0[24]: Copied! <pre>sp.plot_tsne(adata,by='leiden',cmap='tab10',s=3)\n</pre> sp.plot_tsne(adata,by='leiden',cmap='tab10',s=3) <p>Next, we can perform metacell analysis and select slice 10 as an example.</p> In\u00a0[34]: Copied! <pre>adata_s10=adata[adata.obs['slice']==10].copy()\n</pre> adata_s10=adata[adata.obs['slice']==10].copy() In\u00a0[39]: Copied! <pre>adata_s10.obsm['spatial']=adata_s10.obs[['spatial_x','spatial_y']].values\n</pre> adata_s10.obsm['spatial']=adata_s10.obs[['spatial_x','spatial_y']].values In\u00a0[40]: Copied! <pre>adata_s10,clusters=sp.spatial_bigcells(adata_s10,method='walktrap',n_pca=15,n_neighbors=50,distance_threshold=50,\n                              p=5,weights='inverse_distance',a=50,const=0.1)\n</pre> adata_s10,clusters=sp.spatial_bigcells(adata_s10,method='walktrap',n_pca=15,n_neighbors=50,distance_threshold=50,                               p=5,weights='inverse_distance',a=50,const=0.1) In\u00a0[44]: Copied! <pre>category_colors = {\n    0: 'red',\n    1: 'blue',\n    2: 'green',\n    3: 'orange',\n    4: 'cyan',\n    5: 'gray',\n    6: 'purple'\n}\nadata_s10.obs['color'] = [category_colors[category] for category in adata_s10.obs['leiden']]\n</pre> category_colors = {     0: 'red',     1: 'blue',     2: 'green',     3: 'orange',     4: 'cyan',     5: 'gray',     6: 'purple' } adata_s10.obs['color'] = [category_colors[category] for category in adata_s10.obs['leiden']] <p>Next, let's look at metacell's distribution. The scatter colors in the figure below are based on the leiden clustering results</p> In\u00a0[46]: Copied! <pre>sp.spatial_bigcell_plot(adata_s10,color_key='color',s=2,figsize=(5,5),color_key_obs='leiden')\n</pre> sp.spatial_bigcell_plot(adata_s10,color_key='color',s=2,figsize=(5,5),color_key_obs='leiden') <p>Check how many individual cells each metacell has</p> In\u00a0[47]: Copied! <pre>sp.metacell_size(adata_s10,figsize=(3.5,3.5))\n</pre> sp.metacell_size(adata_s10,figsize=(3.5,3.5)) <p>Check the purity of each metacell, defined as the percentage of cells with the largest proportion of cell types in the metacell</p> In\u00a0[48]: Copied! <pre>sp.metacell_purity(adata_s10,figsize=(3.5,3.5),celltype='leiden')\n</pre> sp.metacell_purity(adata_s10,figsize=(3.5,3.5),celltype='leiden') <p>We provide a function that generates a new anndata object in metacell. Its cell count is the sum of the counts of individual cells in metacell. Coordinates are the center of the cell coordinates in metacell. We also assign each metacell an initial cell type, which is determined by the cell type that makes up the largest percentage of the metacell. If more than one cell type has the same proportion, the value is unknown.</p> In\u00a0[50]: Copied! <pre>adata_raw=anndata.read_h5ad('zf10_stereoseq.h5ad')\n</pre> adata_raw=anndata.read_h5ad('zf10_stereoseq.h5ad') In\u00a0[52]: Copied! <pre>adata_s10_raw=adata_raw[adata_raw.obs['slice']==10]\n</pre> adata_s10_raw=adata_raw[adata_raw.obs['slice']==10] In\u00a0[60]: Copied! <pre>adata_s10_raw.obsm['spatial']=adata_s10_raw.obs[['spatial_x','spatial_y']].values\n</pre> adata_s10_raw.obsm['spatial']=adata_s10_raw.obs[['spatial_x','spatial_y']].values In\u00a0[70]: Copied! <pre>new_s10 = sp.generate_membership_anndata(adata_s10_raw, adata_s10,celltype='leiden')\n</pre> new_s10 = sp.generate_membership_anndata(adata_s10_raw, adata_s10,celltype='leiden') In\u00a0[71]: Copied! <pre>new_s10\n</pre> new_s10 Out[71]: <pre>AnnData object with n_obs \u00d7 n_vars = 203 \u00d7 18698\n    obs: 'membership', 'metacell_celltype'\n    obsm: 'spatial'</pre> In\u00a0[72]: Copied! <pre>new_s10.obs['metacell_celltype'].value_counts()\n</pre> new_s10.obs['metacell_celltype'].value_counts() Out[72]: <pre>3          68\n2          51\n4          29\nunknown    17\n1          17\n0          13\n5           4\n6           4\nName: metacell_celltype, dtype: int64</pre> In\u00a0[73]: Copied! <pre>new_s10=sp.filter_cells(new_s10,min_genes=1)\nnew_s10=sp.filter_genes(new_s10,min_cells=1)\n</pre> new_s10=sp.filter_cells(new_s10,min_genes=1) new_s10=sp.filter_genes(new_s10,min_cells=1) In\u00a0[74]: Copied! <pre>sp.violin(adata_s10,feature='n_genes',fig_size=(3,3))\n</pre> sp.violin(adata_s10,feature='n_genes',fig_size=(3,3)) In\u00a0[75]: Copied! <pre>sp.violin(new_s10,feature='n_genes',fig_size=(3,3))\n</pre> sp.violin(new_s10,feature='n_genes',fig_size=(3,3))"},{"location":"Tutorial/Spatial%20metacell%20analysis%20with%20STpipe/#perform-metacell-analysis-using-stpipe","title":"Perform metacell analysis using STpipe.\u00b6","text":""},{"location":"Tutorial/Spatial%20metacell%20analysis%20with%20STpipe/#import-the-required-packages","title":"Import the required packages\u00b6","text":""},{"location":"Tutorial/Spatial%20metacell%20analysis%20with%20STpipe/#import-the-zebrafish-stereo-seq-data","title":"Import the zebrafish Stereo-seq data\u00b6","text":""},{"location":"Tutorial/Spatial%20metacell%20analysis%20with%20STpipe/#filter","title":"Filter\u00b6","text":""},{"location":"Tutorial/Spatial%20metacell%20analysis%20with%20STpipe/#normalize","title":"Normalize\u00b6","text":""},{"location":"Tutorial/Spatial%20metacell%20analysis%20with%20STpipe/#find-variable-genes","title":"Find variable genes\u00b6","text":""},{"location":"Tutorial/Spatial%20metacell%20analysis%20with%20STpipe/#scale","title":"Scale\u00b6","text":""},{"location":"Tutorial/Spatial%20metacell%20analysis%20with%20STpipe/#pca","title":"PCA\u00b6","text":""},{"location":"Tutorial/Spatial%20metacell%20analysis%20with%20STpipe/#determine-the-pcs-used-for-subsequent-analysis","title":"Determine the PCs used for subsequent analysis.\u00b6","text":""},{"location":"Tutorial/Spatial%20metacell%20analysis%20with%20STpipe/#tsne","title":"TSNE\u00b6","text":""},{"location":"Tutorial/Spatial%20metacell%20analysis%20with%20STpipe/#cluster","title":"Cluster\u00b6","text":""},{"location":"Tutorial/Spatial%20metacell%20analysis%20with%20STpipe/#spatial-metacell-analysis","title":"Spatial metacell analysis\u00b6","text":""}]}